name: Release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      version:
        description: "Version to release (e.g., v1.0.0)"
        required: true
        type: string

permissions:
  contents: write
  packages: write

env:
  GO_VERSION: "1.24.6"

jobs:
  validate:
    name: Validate Release
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      is_prerelease: ${{ steps.version.outputs.is_prerelease }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Verify release is from main branch
        run: |
          # For tags, check if the tag is on main branch
          if [ "${{ github.event_name }}" = "push" ]; then
            TAG_COMMIT=$(git rev-list -n 1 ${{ github.ref }})
            MAIN_COMMITS=$(git rev-list origin/main)

            if ! echo "$MAIN_COMMITS" | grep -q "$TAG_COMMIT"; then
              echo "❌ Error: Tag is not on main branch"
              echo "Releases must be created from the main branch"
              exit 1
            fi
            echo "✅ Tag is on main branch"
          fi

          # For workflow_dispatch, check current branch
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            CURRENT_BRANCH=$(git branch --show-current)
            if [ "$CURRENT_BRANCH" != "main" ]; then
              echo "❌ Error: Workflow dispatch must be run from main branch"
              echo "Current branch: $CURRENT_BRANCH"
              exit 1
            fi
            echo "✅ Running from main branch"
          fi

      - name: Get version
        id: version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION=${GITHUB_REF#refs/tags/}
          fi

          # Validate version format
          if ! [[ "$VERSION" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9]+(\.[a-zA-Z0-9]+)*)?$ ]]; then
            echo "❌ Error: Invalid version format: $VERSION"
            echo "Version must match pattern: v1.2.3 or v1.2.3-alpha.1"
            exit 1
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT

          # Check if this is a prerelease (contains alpha, beta, rc, or dev)
          if [[ "$VERSION" =~ (alpha|beta|rc|dev) ]]; then
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
            echo "📦 Prerelease version: $VERSION"
          else
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
            echo "📦 Stable version: $VERSION"
          fi

      - name: Verify CHANGELOG entry
        run: |
          VERSION="${{ steps.version.outputs.version }}"

          # Check if CHANGELOG.md exists
          if [ ! -f CHANGELOG.md ]; then
            echo "⚠️ Warning: CHANGELOG.md not found"
            exit 0
          fi

          # Check if version is mentioned in CHANGELOG
          if ! grep -q "$VERSION" CHANGELOG.md; then
            echo "⚠️ Warning: Version $VERSION not found in CHANGELOG.md"
            echo "Consider updating CHANGELOG.md before releasing"
          else
            echo "✅ Version $VERSION found in CHANGELOG.md"
          fi

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Download dependencies
        run: |
          go mod download
          go mod verify

      - name: Run linter
        uses: golangci/golangci-lint-action@v8
        with:
          version: v2.1.5
          verify: false
          args: --timeout=5m --config .golangci.yml

      - name: Run tests
        run: |
          echo "🧪 Running tests before release..."
          go test -race -p 1 -timeout 10m ./...
          echo "✅ All tests passed"

      - name: Check for uncommitted changes
        run: |
          if [ -n "$(git status --porcelain)" ]; then
            echo "❌ Error: Uncommitted changes detected"
            git status --porcelain
            exit 1
          fi
          echo "✅ Working directory is clean"

  build:
    name: Build Release Binaries
    runs-on: ubuntu-latest
    needs: validate
    strategy:
      matrix:
        include:
          - goos: linux
            goarch: amd64
            suffix: ""
          - goos: linux
            goarch: arm64
            suffix: ""
          - goos: darwin
            goarch: amd64
            suffix: ""
          - goos: darwin
            goarch: arm64
            suffix: ""
          - goos: windows
            goarch: amd64
            suffix: ".exe"

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Download dependencies
        run: |
          go mod download
          go mod verify

      - name: Build binary
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
          CGO_ENABLED: 0
          VERSION: ${{ needs.validate.outputs.version }}
        run: |
          BINARY_NAME="scanorama${{ matrix.suffix }}"
          BUILD_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          COMMIT=$(git rev-parse --short HEAD)

          # Build flags for smaller binaries and version info
          LDFLAGS="-X 'main.version=$VERSION' -X 'main.commit=$COMMIT' -X 'main.buildTime=$BUILD_TIME' -s -w"

          echo "🔨 Building ${{ matrix.goos }}/${{ matrix.goarch }} binary..."
          mkdir -p dist
          go build -ldflags "$LDFLAGS" -o dist/scanorama-${{ matrix.goos }}-${{ matrix.goarch }}${{ matrix.suffix }} ./cmd/scanorama

          # Verify binary was created
          if [ ! -f "dist/scanorama-${{ matrix.goos }}-${{ matrix.goarch }}${{ matrix.suffix }}" ]; then
            echo "❌ Error: Binary not created"
            exit 1
          fi

          # Create archive
          cd dist
          if [ "${{ matrix.goos }}" = "windows" ]; then
            # For Windows, create a zip file
            zip -r scanorama-${{ matrix.goos }}-${{ matrix.goarch }}.zip scanorama-${{ matrix.goos }}-${{ matrix.goarch }}${{ matrix.suffix }}
          else
            # For Unix systems, create a tar.gz
            tar -czf scanorama-${{ matrix.goos }}-${{ matrix.goarch }}.tar.gz scanorama-${{ matrix.goos }}-${{ matrix.goarch }}${{ matrix.suffix }}
          fi

          echo "✅ Built and archived ${{ matrix.goos }}/${{ matrix.goarch }} binary"

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: binary-${{ matrix.goos }}-${{ matrix.goarch }}
          path: dist/
          retention-days: 7

  checksums:
    name: Generate Checksums
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v5
        with:
          path: artifacts

      - name: Collect binaries and generate checksums
        run: |
          mkdir -p release

          # Copy all archives to release directory
          find artifacts -name "*.tar.gz" -o -name "*.zip" | while read file; do
            cp "$file" release/
          done

          # Generate SHA256 checksums
          cd release
          sha256sum * > checksums.txt

          # Generate SHA512 checksums for extra security
          sha512sum * > checksums-sha512.txt

          # Show what we have
          echo "📦 Release artifacts:"
          ls -la
          echo ""
          echo "🔐 SHA256 Checksums:"
          cat checksums.txt
          echo ""
          echo "🔐 SHA512 Checksums:"
          cat checksums-sha512.txt

      - name: Upload release artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-artifacts
          path: release/
          retention-days: 7

  release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [validate, checksums]
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download release artifacts
        uses: actions/download-artifact@v5
        with:
          name: release-artifacts
          path: release/

      - name: Extract CHANGELOG section
        id: changelog
        run: |
          VERSION="${{ needs.validate.outputs.version }}"

          # Try to extract the specific version section from CHANGELOG
          if [ -f CHANGELOG.md ]; then
            # Extract section between this version and the next version header
            awk -v ver="$VERSION" '
              /^## \[?'$VERSION'\]?/ { flag=1; next }
              /^## \[?v[0-9]+\.[0-9]+\.[0-9]+/ && flag { exit }
              flag { print }
            ' CHANGELOG.md > VERSION_NOTES.md

            if [ -s VERSION_NOTES.md ]; then
              echo "📝 Extracted CHANGELOG section for $VERSION"
              cat VERSION_NOTES.md
            else
              echo "📝 No specific CHANGELOG section found for $VERSION"
            fi
          fi

      - name: Generate release notes
        id: release_notes
        run: |
          VERSION="${{ needs.validate.outputs.version }}"

          echo "# Release $VERSION" > RELEASE_NOTES.md
          echo "" >> RELEASE_NOTES.md

          # Add CHANGELOG section if it exists
          if [ -s VERSION_NOTES.md ]; then
            cat VERSION_NOTES.md >> RELEASE_NOTES.md
            echo "" >> RELEASE_NOTES.md
          fi

          # Get the previous tag
          PREV_TAG=$(git tag --sort=-version:refname | grep -E "^v[0-9]+\.[0-9]+\.[0-9]+" | grep -v "$VERSION" | head -n 1)

          echo "## 📋 Changes" >> RELEASE_NOTES.md
          echo "" >> RELEASE_NOTES.md

          if [ -n "$PREV_TAG" ]; then
            echo "### Commits since $PREV_TAG" >> RELEASE_NOTES.md

            # Group commits by type
            echo "" >> RELEASE_NOTES.md
            echo "#### ✨ Features" >> RELEASE_NOTES.md
            git log --pretty=format:"- %s (%h)" $PREV_TAG..HEAD | grep -E "^- feat" | sed 's/^- feat[:(]/- /' || echo "- None"

            echo "" >> RELEASE_NOTES.md
            echo "#### 🐛 Bug Fixes" >> RELEASE_NOTES.md
            git log --pretty=format:"- %s (%h)" $PREV_TAG..HEAD | grep -E "^- fix" | sed 's/^- fix[:(]/- /' || echo "- None"

            echo "" >> RELEASE_NOTES.md
            echo "#### 📚 Documentation" >> RELEASE_NOTES.md
            git log --pretty=format:"- %s (%h)" $PREV_TAG..HEAD | grep -E "^- docs" | sed 's/^- docs[:(]/- /' || echo "- None"

            echo "" >> RELEASE_NOTES.md
            echo "#### 🔧 Other Changes" >> RELEASE_NOTES.md
            git log --pretty=format:"- %s (%h)" $PREV_TAG..HEAD | grep -vE "^- (feat|fix|docs)" || echo "- None"
          else
            echo "### All commits" >> RELEASE_NOTES.md
            git log --pretty=format:"- %s (%h)" --max-count=20 >> RELEASE_NOTES.md
          fi

          echo "" >> RELEASE_NOTES.md
          echo "## 📦 Installation" >> RELEASE_NOTES.md
          echo "" >> RELEASE_NOTES.md
          echo "Download the appropriate binary for your platform from the assets below." >> RELEASE_NOTES.md
          echo "" >> RELEASE_NOTES.md
          echo "### Linux (AMD64)" >> RELEASE_NOTES.md
          echo '```bash' >> RELEASE_NOTES.md
          echo "curl -LO https://github.com/${{ github.repository }}/releases/download/$VERSION/scanorama-linux-amd64.tar.gz" >> RELEASE_NOTES.md
          echo "tar -xzf scanorama-linux-amd64.tar.gz" >> RELEASE_NOTES.md
          echo "chmod +x scanorama-linux-amd64" >> RELEASE_NOTES.md
          echo "sudo mv scanorama-linux-amd64 /usr/local/bin/scanorama" >> RELEASE_NOTES.md
          echo "scanorama version" >> RELEASE_NOTES.md
          echo '```' >> RELEASE_NOTES.md
          echo "" >> RELEASE_NOTES.md
          echo "### macOS (Apple Silicon)" >> RELEASE_NOTES.md
          echo '```bash' >> RELEASE_NOTES.md
          echo "curl -LO https://github.com/${{ github.repository }}/releases/download/$VERSION/scanorama-darwin-arm64.tar.gz" >> RELEASE_NOTES.md
          echo "tar -xzf scanorama-darwin-arm64.tar.gz" >> RELEASE_NOTES.md
          echo "chmod +x scanorama-darwin-arm64" >> RELEASE_NOTES.md
          echo "sudo mv scanorama-darwin-arm64 /usr/local/bin/scanorama" >> RELEASE_NOTES.md
          echo "scanorama version" >> RELEASE_NOTES.md
          echo '```' >> RELEASE_NOTES.md
          echo "" >> RELEASE_NOTES.md
          echo "### Windows" >> RELEASE_NOTES.md
          echo '```powershell' >> RELEASE_NOTES.md
          echo "# Download the Windows binary" >> RELEASE_NOTES.md
          echo "Invoke-WebRequest -Uri \"https://github.com/${{ github.repository }}/releases/download/$VERSION/scanorama-windows-amd64.zip\" -OutFile \"scanorama.zip\"" >> RELEASE_NOTES.md
          echo "Expand-Archive -Path \"scanorama.zip\" -DestinationPath ." >> RELEASE_NOTES.md
          echo "./scanorama-windows-amd64.exe version" >> RELEASE_NOTES.md
          echo '```' >> RELEASE_NOTES.md
          echo "" >> RELEASE_NOTES.md
          echo "## 🔐 Verification" >> RELEASE_NOTES.md
          echo "" >> RELEASE_NOTES.md
          echo "All binaries can be verified using the provided checksum files:" >> RELEASE_NOTES.md
          echo '```bash' >> RELEASE_NOTES.md
          echo "# SHA256" >> RELEASE_NOTES.md
          echo "sha256sum -c checksums.txt" >> RELEASE_NOTES.md
          echo "" >> RELEASE_NOTES.md
          echo "# SHA512" >> RELEASE_NOTES.md
          echo "sha512sum -c checksums-sha512.txt" >> RELEASE_NOTES.md
          echo '```' >> RELEASE_NOTES.md
          echo "" >> RELEASE_NOTES.md
          echo "## 📋 Requirements" >> RELEASE_NOTES.md
          echo "" >> RELEASE_NOTES.md
          echo "- Go 1.24.6+ (for building from source)" >> RELEASE_NOTES.md
          echo "- nmap 7.0+ (runtime dependency)" >> RELEASE_NOTES.md
          echo "- PostgreSQL 13+ (for database storage)" >> RELEASE_NOTES.md

          echo "📝 Release notes generated"

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.validate.outputs.version }}
          name: ${{ needs.validate.outputs.version }}
          body_path: RELEASE_NOTES.md
          files: release/*
          prerelease: ${{ needs.validate.outputs.is_prerelease == 'true' }}
          draft: false
          fail_on_unmatched_files: true
          generate_release_notes: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Update latest tag (stable releases only)
        if: needs.validate.outputs.is_prerelease == 'false'
        run: |
          VERSION="${{ needs.validate.outputs.version }}"

          # Update or create 'latest' tag pointing to this release
          git tag -f latest $VERSION
          git push origin latest --force

          echo "✅ Updated 'latest' tag to point to $VERSION"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
