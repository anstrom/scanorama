
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>handlers: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/anstrom/scanorama/internal/api/handlers/admin.go (0.0%)</option>
				
				<option value="file1">github.com/anstrom/scanorama/internal/api/handlers/common.go (82.6%)</option>
				
				<option value="file2">github.com/anstrom/scanorama/internal/api/handlers/discovery.go (0.0%)</option>
				
				<option value="file3">github.com/anstrom/scanorama/internal/api/handlers/health.go (16.2%)</option>
				
				<option value="file4">github.com/anstrom/scanorama/internal/api/handlers/host.go (0.0%)</option>
				
				<option value="file5">github.com/anstrom/scanorama/internal/api/handlers/manager.go (0.0%)</option>
				
				<option value="file6">github.com/anstrom/scanorama/internal/api/handlers/profile.go (0.0%)</option>
				
				<option value="file7">github.com/anstrom/scanorama/internal/api/handlers/scan.go (0.0%)</option>
				
				<option value="file8">github.com/anstrom/scanorama/internal/api/handlers/schedule.go (0.0%)</option>
				
				<option value="file9">github.com/anstrom/scanorama/internal/api/handlers/websocket.go (0.0%)</option>
				
				<option value="file10">github.com/anstrom/scanorama/internal/api/middleware/middleware.go (96.8%)</option>
				
				<option value="file11">github.com/anstrom/scanorama/internal/api/server.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package handlers provides HTTP request handlers for the Scanorama API.
// This file implements administrative endpoints for system management,
// worker control, configuration management, and log retrieval.
package handlers

import (
        "context"
        "fmt"
        "log/slog"
        "net/http"
        "strconv"
        "time"

        "github.com/anstrom/scanorama/internal/db"
        "github.com/anstrom/scanorama/internal/metrics"
        "github.com/gorilla/mux"
)

// Admin operation constants.
const (
        workerStopDelay = 100 * time.Millisecond
)

// AdminHandler handles administrative API endpoints.
type AdminHandler struct {
        database *db.DB
        logger   *slog.Logger
        metrics  *metrics.Registry
}

// NewAdminHandler creates a new admin handler.
func NewAdminHandler(database *db.DB, logger *slog.Logger, metricsManager *metrics.Registry) *AdminHandler <span class="cov0" title="0">{
        return &amp;AdminHandler{
                database: database,
                logger:   logger.With("handler", "admin"),
                metrics:  metricsManager,
        }
}</span>

// WorkerStatusResponse represents worker pool status information.
type WorkerStatusResponse struct {
        TotalWorkers   int                    `json:"total_workers"`
        ActiveWorkers  int                    `json:"active_workers"`
        IdleWorkers    int                    `json:"idle_workers"`
        QueueSize      int                    `json:"queue_size"`
        ProcessedJobs  int64                  `json:"processed_jobs"`
        FailedJobs     int64                  `json:"failed_jobs"`
        AvgJobDuration time.Duration          `json:"avg_job_duration"`
        Workers        []WorkerInfo           `json:"workers"`
        Summary        map[string]interface{} `json:"summary"`
        Timestamp      time.Time              `json:"timestamp"`
}

// WorkerInfo represents individual worker information.
type WorkerInfo struct {
        ID            string         `json:"id"`
        Status        string         `json:"status"`
        CurrentJob    *JobInfo       `json:"current_job,omitempty"`
        JobsProcessed int64          `json:"jobs_processed"`
        JobsFailed    int64          `json:"jobs_failed"`
        LastJobTime   *time.Time     `json:"last_job_time,omitempty"`
        StartTime     time.Time      `json:"start_time"`
        Uptime        time.Duration  `json:"uptime"`
        MemoryUsage   int64          `json:"memory_usage_bytes"`
        CPUUsage      float64        `json:"cpu_usage_percent"`
        ErrorRate     float64        `json:"error_rate"`
        Metrics       map[string]int `json:"metrics"`
}

// JobInfo represents current job information.
type JobInfo struct {
        ID        string        `json:"id"`
        Type      string        `json:"type"`
        Target    string        `json:"target,omitempty"`
        StartTime time.Time     `json:"start_time"`
        Duration  time.Duration `json:"duration"`
        Progress  float64       `json:"progress"`
}

// ConfigResponse represents configuration information.
type ConfigResponse struct {
        API      interface{} `json:"api"`
        Database interface{} `json:"database"`
        Scanning interface{} `json:"scanning"`
        Logging  interface{} `json:"logging"`
        Daemon   interface{} `json:"daemon"`
}

// ConfigUpdateRequest represents a configuration update request.
type ConfigUpdateRequest struct {
        Section string      `json:"section" validate:"required,oneof=api database scanning logging daemon"`
        Config  interface{} `json:"config" validate:"required"`
}

// LogsResponse represents log retrieval response.
type LogsResponse struct {
        Lines       []LogEntry `json:"lines"`
        TotalLines  int        `json:"total_lines"`
        StartLine   int        `json:"start_line"`
        EndLine     int        `json:"end_line"`
        HasMore     bool       `json:"has_more"`
        GeneratedAt time.Time  `json:"generated_at"`
}

// LogEntry represents a single log entry.
type LogEntry struct {
        Timestamp time.Time              `json:"timestamp"`
        Level     string                 `json:"level"`
        Message   string                 `json:"message"`
        Component string                 `json:"component,omitempty"`
        Fields    map[string]interface{} `json:"fields,omitempty"`
        Error     string                 `json:"error,omitempty"`
}

// GetWorkerStatus handles GET /api/v1/admin/workers - get worker pool status.
func (h *AdminHandler) GetWorkerStatus(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        requestID := getRequestIDFromContext(r.Context())
        h.logger.Info("Getting worker status", "request_id", requestID)

        // Get worker status from database/worker manager
        // For now, return mock data until worker management is implemented
        workers := []WorkerInfo{
                {
                        ID:            "worker-001",
                        Status:        "active",
                        JobsProcessed: 42,
                        JobsFailed:    2,
                        StartTime:     time.Now().Add(-2 * time.Hour),
                        Uptime:        2 * time.Hour,
                        MemoryUsage:   1024 * 1024 * 50, // 50MB
                        CPUUsage:      15.5,
                        ErrorRate:     0.047,
                        Metrics: map[string]int{
                                "scans_completed":     35,
                                "discovery_completed": 7,
                                "errors":              2,
                        },
                },
                {
                        ID:            "worker-002",
                        Status:        "idle",
                        JobsProcessed: 28,
                        JobsFailed:    1,
                        StartTime:     time.Now().Add(-1 * time.Hour),
                        Uptime:        1 * time.Hour,
                        MemoryUsage:   1024 * 1024 * 32, // 32MB
                        CPUUsage:      5.2,
                        ErrorRate:     0.036,
                        Metrics: map[string]int{
                                "scans_completed":     25,
                                "discovery_completed": 3,
                                "errors":              1,
                        },
                },
        }

        response := WorkerStatusResponse{
                TotalWorkers:   len(workers),
                ActiveWorkers:  1,
                IdleWorkers:    1,
                QueueSize:      0,
                ProcessedJobs:  70,
                FailedJobs:     3,
                AvgJobDuration: 5 * time.Minute,
                Workers:        workers,
                Summary: map[string]interface{}{
                        "total_scans_completed":     60,
                        "total_discovery_completed": 10,
                        "overall_error_rate":        0.043,
                        "queue_throughput_per_hour": 35,
                },
                Timestamp: time.Now().UTC(),
        }

        writeJSON(w, r, http.StatusOK, response)

        // Record metrics
        if h.metrics != nil </span><span class="cov0" title="0">{
                h.metrics.Counter("api_admin_worker_status_total", nil)
        }</span>
}

// StopWorker handles POST /api/v1/admin/workers/{id}/stop - stop a specific worker.
func (h *AdminHandler) StopWorker(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        requestID := getRequestIDFromContext(r.Context())

        // Extract worker ID from URL
        workerID, err := h.extractWorkerID(r)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, r, http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Stopping worker", "request_id", requestID, "worker_id", workerID)

        // Parse request options
        graceful := r.URL.Query().Get("graceful") != "false" // Default to graceful shutdown

        // Stop worker (placeholder implementation)
        h.stopWorker(r.Context(), workerID, graceful)

        response := map[string]interface{}{
                "worker_id":  workerID,
                "status":     "stopped",
                "graceful":   graceful,
                "message":    "Worker has been stopped",
                "timestamp":  time.Now().UTC(),
                "request_id": requestID,
        }

        h.logger.Info("Worker stopped successfully",
                "request_id", requestID,
                "worker_id", workerID,
                "graceful", graceful)

        writeJSON(w, r, http.StatusOK, response)

        // Record metrics
        if h.metrics != nil </span><span class="cov0" title="0">{
                h.metrics.Counter("api_admin_workers_stopped_total", map[string]string{
                        "graceful": strconv.FormatBool(graceful),
                })
        }</span>
}

// GetConfig handles GET /api/v1/admin/config - get current configuration.
func (h *AdminHandler) GetConfig(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        requestID := getRequestIDFromContext(r.Context())
        h.logger.Info("Getting configuration", "request_id", requestID)

        // Get configuration sections
        section := r.URL.Query().Get("section")

        // Get full config or specific section
        config, err := h.getCurrentConfig(r.Context(), section)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get configuration", "request_id", requestID, "error", err)
                writeError(w, r, http.StatusInternalServerError,
                        fmt.Errorf("failed to retrieve configuration: %w", err))
                return
        }</span>

        <span class="cov0" title="0">writeJSON(w, r, http.StatusOK, config)

        // Record metrics
        if h.metrics != nil </span><span class="cov0" title="0">{
                h.metrics.Counter("api_admin_config_retrieved_total", map[string]string{
                        "section": section,
                })
        }</span>
}

// UpdateConfig handles PUT /api/v1/admin/config - update configuration.
func (h *AdminHandler) UpdateConfig(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        requestID := getRequestIDFromContext(r.Context())
        h.logger.Info("Updating configuration", "request_id", requestID)

        // Parse request body
        var req ConfigUpdateRequest
        if err := parseJSON(r, &amp;req); err != nil </span><span class="cov0" title="0">{
                writeError(w, r, http.StatusBadRequest, err)
                return
        }</span>

        // Validate request
        <span class="cov0" title="0">if err := h.validateConfigUpdate(&amp;req); err != nil </span><span class="cov0" title="0">{
                writeError(w, r, http.StatusBadRequest, err)
                return
        }</span>

        // Update configuration
        <span class="cov0" title="0">configMap, ok := req.Config.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                writeError(w, r, http.StatusBadRequest, fmt.Errorf("invalid config format: expected map"))
                return
        }</span>
        <span class="cov0" title="0">updatedConfig := h.updateConfig(r.Context(), req.Section, configMap)

        response := map[string]interface{}{
                "section":          req.Section,
                "status":           "updated",
                "message":          fmt.Sprintf("Configuration section '%s' has been updated", req.Section),
                "config":           updatedConfig,
                "timestamp":        time.Now().UTC(),
                "request_id":       requestID,
                "restart_required": h.isRestartRequired(req.Section),
        }

        h.logger.Info("Configuration updated successfully",
                "request_id", requestID,
                "section", req.Section)

        writeJSON(w, r, http.StatusOK, response)

        // Record metrics
        if h.metrics != nil </span><span class="cov0" title="0">{
                h.metrics.Counter("api_admin_config_updated_total", map[string]string{
                        "section": req.Section,
                })
        }</span>
}

// GetLogs handles GET /api/v1/admin/logs - retrieve system logs.
func (h *AdminHandler) GetLogs(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        requestID := getRequestIDFromContext(r.Context())
        h.logger.Info("Getting logs", "request_id", requestID)

        // Parse query parameters
        level := r.URL.Query().Get("level")         // Filter by log level
        component := r.URL.Query().Get("component") // Filter by component
        since := r.URL.Query().Get("since")         // Time filter
        until := r.URL.Query().Get("until")         // Time filter
        tail := r.URL.Query().Get("tail")           // Number of recent lines
        search := r.URL.Query().Get("search")       // Search term

        // Parse pagination parameters
        params, err := getPaginationParams(r)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, r, http.StatusBadRequest, err)
                return
        }</span>

        // Build log filters
        <span class="cov0" title="0">filters := map[string]interface{}{
                "level":     level,
                "component": component,
                "search":    search,
        }

        // Parse time filters
        if since != "" </span><span class="cov0" title="0">{
                if sinceTime, err := time.Parse(time.RFC3339, since); err == nil </span><span class="cov0" title="0">{
                        filters["since"] = sinceTime
                }</span>
        }
        <span class="cov0" title="0">if until != "" </span><span class="cov0" title="0">{
                if untilTime, err := time.Parse(time.RFC3339, until); err == nil </span><span class="cov0" title="0">{
                        filters["until"] = untilTime
                }</span>
        }

        // Parse tail parameter
        <span class="cov0" title="0">if tail != "" </span><span class="cov0" title="0">{
                if tailLines, err := strconv.Atoi(tail); err == nil &amp;&amp; tailLines &gt; 0 </span><span class="cov0" title="0">{
                        filters["tail"] = tailLines
                }</span>
        }

        // Get logs from database/log manager
        <span class="cov0" title="0">logs, total := h.getLogs(r.Context(), filters, params.Offset, params.PageSize)

        response := LogsResponse{
                Lines:       logs,
                TotalLines:  int(total),
                StartLine:   params.Offset + 1,
                EndLine:     params.Offset + len(logs),
                HasMore:     int64(params.Offset+len(logs)) &lt; total,
                GeneratedAt: time.Now().UTC(),
        }

        writeJSON(w, r, http.StatusOK, response)

        // Record metrics
        if h.metrics != nil </span><span class="cov0" title="0">{
                h.metrics.Counter("api_admin_logs_retrieved_total", map[string]string{
                        "level":     level,
                        "component": component,
                })
        }</span>
}

// Helper methods

// extractWorkerID extracts the worker ID from the URL path.
func (h *AdminHandler) extractWorkerID(r *http.Request) (string, error) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        workerID, exists := vars["id"]
        if !exists </span><span class="cov0" title="0">{
                return "", fmt.Errorf("worker ID not provided")
        }</span>

        <span class="cov0" title="0">if workerID == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("worker ID cannot be empty")
        }</span>

        <span class="cov0" title="0">return workerID, nil</span>
}

// validateConfigUpdate validates a configuration update request.
func (h *AdminHandler) validateConfigUpdate(req *ConfigUpdateRequest) error <span class="cov0" title="0">{
        if req.Section == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("configuration section is required")
        }</span>

        <span class="cov0" title="0">validSections := map[string]bool{
                "api":      true,
                "database": true,
                "scanning": true,
                "logging":  true,
                "daemon":   true,
        }

        if !validSections[req.Section] </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid configuration section: %s", req.Section)
        }</span>

        <span class="cov0" title="0">if req.Config == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("configuration data is required")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// stopWorker stops a specific worker (placeholder implementation).
func (h *AdminHandler) stopWorker(_ context.Context, workerID string, graceful bool) <span class="cov0" title="0">{
        // This would interface with the actual worker manager
        // For now, return a placeholder implementation

        h.logger.Info("Stopping worker", "worker_id", workerID, "graceful", graceful)

        // Simulate worker stopping logic
        time.Sleep(workerStopDelay)

        // In a real implementation, this would:
        // 1. Find the worker by ID
        // 2. Signal it to stop (graceful or immediate)
        // 3. Wait for confirmation or timeout
        // 4. Return appropriate error if stop failed
}</span>

// getCurrentConfig retrieves current configuration.
func (h *AdminHandler) getCurrentConfig(_ context.Context, section string) (map[string]interface{}, error) <span class="cov0" title="0">{
        // This would get the actual configuration from the config manager
        // For now, return mock configuration data

        config := ConfigResponse{
                API: map[string]interface{}{
                        "enabled":             true,
                        "host":                "127.0.0.1",
                        "port":                8080,
                        "auth_enabled":        false,
                        "rate_limit_enabled":  true,
                        "rate_limit_requests": 100,
                        "read_timeout":        "10s",
                        "write_timeout":       "10s",
                },
                Database: map[string]interface{}{
                        "host":            "localhost",
                        "port":            5432,
                        "database":        "scanorama",
                        "ssl_mode":        "require",
                        "max_connections": 25,
                },
                Scanning: map[string]interface{}{
                        "worker_pool_size":         10,
                        "default_scan_type":        "connect",
                        "max_concurrent_targets":   100,
                        "default_ports":            "22,80,443,8080,8443",
                        "enable_service_detection": true,
                },
                Logging: map[string]interface{}{
                        "level":      "info",
                        "format":     "text",
                        "output":     "stdout",
                        "structured": true,
                },
                Daemon: map[string]interface{}{
                        "pid_file":         "/tmp/scanorama.pid",
                        "shutdown_timeout": "30s",
                        "daemonize":        true,
                },
        }

        // Return specific section if requested
        if section != "" </span><span class="cov0" title="0">{
                switch section </span>{
                case "api":<span class="cov0" title="0">
                        return config.API.(map[string]interface{}), nil</span>
                case "database":<span class="cov0" title="0">
                        return config.Database.(map[string]interface{}), nil</span>
                case "scanning":<span class="cov0" title="0">
                        return config.Scanning.(map[string]interface{}), nil</span>
                case "logging":<span class="cov0" title="0">
                        return config.Logging.(map[string]interface{}), nil</span>
                case "daemon":<span class="cov0" title="0">
                        return config.Daemon.(map[string]interface{}), nil</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("unknown configuration section: %s", section)</span>
                }
        }

        // Return entire config as map
        <span class="cov0" title="0">return map[string]interface{}{
                "api":      config.API,
                "database": config.Database,
                "scanning": config.Scanning,
                "logging":  config.Logging,
                "daemon":   config.Daemon,
        }, nil</span>
}

// updateConfig updates configuration (placeholder implementation).
func (h *AdminHandler) updateConfig(
        _ context.Context,
        section string,
        config map[string]interface{},
) map[string]interface{} <span class="cov0" title="0">{
        // This would interface with the actual configuration manager
        // For now, return a placeholder implementation

        h.logger.Info("Updating configuration", "section", section)

        // In a real implementation, this would:
        // 1. Validate the configuration data for the specific section
        // 2. Update the configuration in memory and/or file
        // 3. Apply changes that can be applied without restart
        // 4. Return the updated configuration

        // For now, just return the input data as if it was applied
        return config
}</span>

// isRestartRequired checks if a configuration change requires restart.
func (h *AdminHandler) isRestartRequired(section string) bool <span class="cov0" title="0">{
        // Define which configuration sections require restart
        restartRequired := map[string]bool{
                "api":      true,  // Changing API settings requires restart
                "database": true,  // Database connection changes require restart
                "daemon":   true,  // Daemon settings require restart
                "scanning": false, // Most scanning settings can be applied at runtime
                "logging":  false, // Logging settings can be applied at runtime
        }

        return restartRequired[section]
}</span>

// getLogs retrieves system logs (placeholder implementation).
func (h *AdminHandler) getLogs(
        _ context.Context,
        filters map[string]interface{},
        offset, limit int,
) (logs []LogEntry, total int64) <span class="cov0" title="0">{
        // This would interface with the actual logging system
        // For now, return mock log data

        logs = []LogEntry{
                {
                        Timestamp: time.Now().Add(-5 * time.Minute),
                        Level:     "info",
                        Message:   "Scan completed successfully",
                        Component: "scanner",
                        Fields: map[string]interface{}{
                                "scan_id":     123,
                                "target":      "192.168.1.1",
                                "duration_ms": 2500,
                        },
                },
                {
                        Timestamp: time.Now().Add(-10 * time.Minute),
                        Level:     "warn",
                        Message:   "Database connection pool running low",
                        Component: "database",
                        Fields: map[string]interface{}{
                                "active_connections": 23,
                                "max_connections":    25,
                        },
                },
                {
                        Timestamp: time.Now().Add(-15 * time.Minute),
                        Level:     "error",
                        Message:   "Failed to resolve hostname",
                        Component: "discovery",
                        Error:     "no such host",
                        Fields: map[string]interface{}{
                                "hostname": "invalid.example.com",
                                "job_id":   456,
                        },
                },
                {
                        Timestamp: time.Now().Add(-20 * time.Minute),
                        Level:     "info",
                        Message:   "Worker started",
                        Component: "worker",
                        Fields: map[string]interface{}{
                                "worker_id": "worker-001",
                                "pool_size": 10,
                        },
                },
        }

        // Apply filters (basic implementation)
        filteredLogs := []LogEntry{}
        for _, log := range logs </span><span class="cov0" title="0">{
                if h.matchesFilters(&amp;log, filters) </span><span class="cov0" title="0">{
                        filteredLogs = append(filteredLogs, log)
                }</span>
        }

        // Apply pagination
        <span class="cov0" title="0">start := offset
        end := offset + limit
        total = int64(len(filteredLogs))

        if start &gt;= len(filteredLogs) </span><span class="cov0" title="0">{
                return []LogEntry{}, total
        }</span>
        <span class="cov0" title="0">if end &gt; len(filteredLogs) </span><span class="cov0" title="0">{
                end = len(filteredLogs)
        }</span>

        <span class="cov0" title="0">return filteredLogs[start:end], total</span>
}

// matchesFilters checks if a log entry matches the given filters.
func (h *AdminHandler) matchesFilters(log *LogEntry, filters map[string]interface{}) bool <span class="cov0" title="0">{
        if level, ok := filters["level"].(string); ok &amp;&amp; level != "" </span><span class="cov0" title="0">{
                if log.Level != level </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">if component, ok := filters["component"].(string); ok &amp;&amp; component != "" </span><span class="cov0" title="0">{
                if log.Component != component </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">if search, ok := filters["search"].(string); ok &amp;&amp; search != "" </span><span class="cov0" title="0">{
                if !contains(log.Message, search) &amp;&amp; !contains(log.Error, search) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">if since, ok := filters["since"].(time.Time); ok </span><span class="cov0" title="0">{
                if log.Timestamp.Before(since) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">if until, ok := filters["until"].(time.Time); ok </span><span class="cov0" title="0">{
                if log.Timestamp.After(until) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// contains performs case-insensitive substring search.
func contains(str, substr string) bool <span class="cov0" title="0">{
        return len(str) &gt;= len(substr) &amp;&amp;
                (str == substr ||
                        substr == "" ||
                        str[:len(substr)] == substr ||
                        str[len(str)-len(substr):] == substr ||
                        containsRecursive(str, substr))
}</span>

func containsRecursive(str, substr string) bool <span class="cov0" title="0">{
        if len(str) &lt; len(substr) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for i := 0; i &lt;= len(str)-len(substr); i++ </span><span class="cov0" title="0">{
                if str[i:i+len(substr)] == substr </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package handlers provides HTTP request handlers for the Scanorama API.
// This file contains common utilities shared across all handlers to reduce
// code duplication and provide consistent patterns.
package handlers

import (
        "context"
        "encoding/json"
        "fmt"
        "log/slog"
        "net/http"
        "strconv"
        "time"

        "github.com/google/uuid"
        "github.com/gorilla/mux"

        "github.com/anstrom/scanorama/internal/errors"
        "github.com/anstrom/scanorama/internal/metrics"
)

// ContextKey represents a context key type.
type ContextKey string

// PaginationParams holds pagination parameters.
type PaginationParams struct {
        Page     int `json:"page"`
        PageSize int `json:"page_size"`
        Offset   int `json:"offset"`
}

// PaginatedResponse represents a paginated API response.
type PaginatedResponse struct {
        Data       interface{} `json:"data"`
        Pagination struct {
                Page       int   `json:"page"`
                PageSize   int   `json:"page_size"`
                TotalItems int64 `json:"total_items"`
                TotalPages int   `json:"total_pages"`
        } `json:"pagination"`
}

// ErrorResponse represents an API error response.
type ErrorResponse struct {
        Error     string    `json:"error"`
        Message   string    `json:"message"`
        Timestamp time.Time `json:"timestamp"`
        RequestID string    `json:"request_id,omitempty"`
}

// BaseHandler provides common functionality for all handlers.
type BaseHandler struct {
        logger  *slog.Logger
        metrics metrics.MetricsRegistry
}

// NewBaseHandler creates a new base handler.
func NewBaseHandler(logger *slog.Logger, metricsRegistry metrics.MetricsRegistry) *BaseHandler <span class="cov8" title="1">{
        return &amp;BaseHandler{
                logger:  logger,
                metrics: metricsRegistry,
        }
}</span>

// Common utility functions

// getRequestIDFromContext extracts request ID from context.
func getRequestIDFromContext(ctx context.Context) string <span class="cov8" title="1">{
        if requestID, ok := ctx.Value(ContextKey("request_id")).(string); ok </span><span class="cov8" title="1">{
                return requestID
        }</span>
        <span class="cov8" title="1">return "unknown"</span>
}

// getQueryParamInt extracts integer query parameter with default value.
func getQueryParamInt(r *http.Request, key string, defaultValue int) (int, error) <span class="cov8" title="1">{
        if value := r.URL.Query().Get(key); value != "" </span><span class="cov8" title="1">{
                return strconv.Atoi(value)
        }</span>
        <span class="cov8" title="1">return defaultValue, nil</span>
}

// extractUUIDFromPath extracts UUID from URL path parameter.
func extractUUIDFromPath(r *http.Request) (uuid.UUID, error) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        idStr, exists := vars["id"]
        if !exists </span><span class="cov8" title="1">{
                return uuid.Nil, fmt.Errorf("id not provided")
        }</span>

        <span class="cov8" title="1">id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov8" title="1">{
                return uuid.Nil, fmt.Errorf("invalid id: %s", idStr)
        }</span>

        <span class="cov8" title="1">return id, nil</span>
}

// Pagination utilities

// getPaginationParams extracts pagination parameters from request.
func getPaginationParams(r *http.Request) (PaginationParams, error) <span class="cov8" title="1">{
        const (
                defaultPage     = 1
                defaultPageSize = 50
                maxPageSize     = 1000
        )

        page, err := getQueryParamInt(r, "page", defaultPage)
        if err != nil </span><span class="cov8" title="1">{
                return PaginationParams{}, fmt.Errorf("invalid page parameter: %w", err)
        }</span>

        <span class="cov8" title="1">pageSize, err := getQueryParamInt(r, "page_size", defaultPageSize)
        if err != nil </span><span class="cov8" title="1">{
                return PaginationParams{}, fmt.Errorf("invalid page_size parameter: %w", err)
        }</span>

        <span class="cov8" title="1">if page &lt; 1 </span><span class="cov8" title="1">{
                page = defaultPage
        }</span>

        <span class="cov8" title="1">if pageSize &lt; 1 </span><span class="cov8" title="1">{
                pageSize = defaultPageSize
        }</span>

        <span class="cov8" title="1">if pageSize &gt; maxPageSize </span><span class="cov8" title="1">{
                pageSize = maxPageSize
        }</span>

        <span class="cov8" title="1">offset := (page - 1) * pageSize

        return PaginationParams{
                Page:     page,
                PageSize: pageSize,
                Offset:   offset,
        }, nil</span>
}

// Response utilities

// writeJSON writes a JSON response with the given status code.
func writeJSON(w http.ResponseWriter, r *http.Request, statusCode int, data interface{}) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)

        if err := json.NewEncoder(w).Encode(data); err != nil </span><span class="cov0" title="0">{
                // Log error but don't try to write another response
                requestID := getRequestIDFromContext(r.Context())
                slog.Error("Failed to encode JSON response",
                        "request_id", requestID,
                        "error", err)
        }</span>
}

// writeError writes an error response.
func writeError(w http.ResponseWriter, r *http.Request, statusCode int, err error) <span class="cov8" title="1">{
        requestID := getRequestIDFromContext(r.Context())

        response := ErrorResponse{
                Error:     http.StatusText(statusCode),
                Message:   err.Error(),
                Timestamp: time.Now().UTC(),
                RequestID: requestID,
        }

        writeJSON(w, r, statusCode, response)
}</span>

// writePaginatedResponse writes a paginated response.
func writePaginatedResponse(
        w http.ResponseWriter,
        r *http.Request,
        data interface{},
        params PaginationParams,
        totalItems int64,
) <span class="cov8" title="1">{
        totalPages := int((totalItems + int64(params.PageSize) - 1) / int64(params.PageSize))

        response := PaginatedResponse{
                Data: data,
        }
        response.Pagination.Page = params.Page
        response.Pagination.PageSize = params.PageSize
        response.Pagination.TotalItems = totalItems
        response.Pagination.TotalPages = totalPages

        writeJSON(w, r, http.StatusOK, response)
}</span>

// Request parsing utilities

// parseJSON parses JSON request body into the provided destination.
func parseJSON(r *http.Request, dest interface{}) error <span class="cov8" title="1">{
        if r.Body == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("request body is empty")
        }</span>

        <span class="cov8" title="1">decoder := json.NewDecoder(r.Body)
        decoder.DisallowUnknownFields()

        if err := decoder.Decode(dest); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid JSON: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// CRUD operation patterns

// CRUDMetrics holds metric names for CRUD operations.
type CRUDMetrics struct {
        Listed    string
        Created   string
        Retrieved string
        Updated   string
        Deleted   string
        Started   string
        Stopped   string
}

// recordCRUDMetric records a CRUD operation metric.
func recordCRUDMetric(metricsRegistry metrics.MetricsRegistry, metricName string, labels map[string]string) <span class="cov8" title="1">{
        if metricsRegistry != nil </span><span class="cov8" title="1">{
                metricsRegistry.Counter(metricName, labels)
        }</span>
}

// Operation result helpers

// handleDatabaseError handles common database errors and writes appropriate HTTP responses.
func handleDatabaseError(
        w http.ResponseWriter,
        r *http.Request,
        err error,
        operation, entityType string,
        logger *slog.Logger,
) <span class="cov8" title="1">{
        requestID := getRequestIDFromContext(r.Context())

        if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                writeError(w, r, http.StatusNotFound, fmt.Errorf("%s not found", entityType))
                return
        }</span>

        <span class="cov8" title="1">if errors.IsConflict(err) </span><span class="cov8" title="1">{
                writeError(w, r, http.StatusConflict, err)
                return
        }</span>

        <span class="cov8" title="1">logger.Error(fmt.Sprintf("Failed to %s %s", operation, entityType),
                "request_id", requestID,
                "error", err)
        writeError(w, r, http.StatusInternalServerError,
                fmt.Errorf("failed to %s %s: %w", operation, entityType, err))</span>
}

// ListOperation is a generic list operation pattern.
type ListOperation[T any, F any] struct {
        EntityType string
        MetricName string
        Logger     *slog.Logger
        Metrics    metrics.MetricsRegistry
        GetFilters func(*http.Request) F
        ListFromDB func(context.Context, F, int, int) ([]T, int64, error)
        ToResponse func(T) interface{}
}

// Execute performs a generic list operation.
func (op *ListOperation[T, F]) Execute(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        requestID := getRequestIDFromContext(r.Context())
        op.Logger.Info(fmt.Sprintf("Listing %s", op.EntityType), "request_id", requestID)

        // Parse pagination parameters
        params, err := getPaginationParams(r)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, r, http.StatusBadRequest, err)
                return
        }</span>

        // Parse filter parameters
        <span class="cov8" title="1">filters := op.GetFilters(r)

        // Get items from database
        items, total, err := op.ListFromDB(r.Context(), filters, params.Offset, params.PageSize)
        if err != nil </span><span class="cov0" title="0">{
                handleDatabaseError(w, r, err, "list", op.EntityType, op.Logger)
                return
        }</span>

        // Convert to response format
        <span class="cov8" title="1">responses := make([]interface{}, len(items))
        for i, item := range items </span><span class="cov8" title="1">{
                responses[i] = op.ToResponse(item)
        }</span>

        // Write paginated response
        <span class="cov8" title="1">writePaginatedResponse(w, r, responses, params, total)

        // Record metrics
        recordCRUDMetric(op.Metrics, op.MetricName, map[string]string{
                "status": "success",
        })</span>
}

// CRUDOperation is a generic CRUD operation pattern.
type CRUDOperation[T any] struct {
        EntityType string
        Logger     *slog.Logger
        Metrics    metrics.MetricsRegistry
}

// ExecuteGet performs a generic get operation.
func (op *CRUDOperation[T]) ExecuteGet(
        w http.ResponseWriter,
        r *http.Request,
        id uuid.UUID,
        getFromDB func(context.Context, uuid.UUID) (*T, error),
        toResponse func(*T) interface{},
        metricName string,
) <span class="cov8" title="1">{
        requestID := getRequestIDFromContext(r.Context())
        op.Logger.Info(fmt.Sprintf("Getting %s", op.EntityType), "request_id", requestID, "id", id)

        // Get item from database
        item, err := getFromDB(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                handleDatabaseError(w, r, err, "get", op.EntityType, op.Logger)
                return
        }</span>

        <span class="cov8" title="1">response := toResponse(item)
        writeJSON(w, r, http.StatusOK, response)

        // Record metrics
        recordCRUDMetric(op.Metrics, metricName, nil)</span>
}

// ExecuteDelete performs a generic delete operation.
func (op *CRUDOperation[T]) ExecuteDelete(
        w http.ResponseWriter,
        r *http.Request,
        id uuid.UUID,
        deleteFromDB func(context.Context, uuid.UUID) error,
        metricName string,
) <span class="cov8" title="1">{
        requestID := getRequestIDFromContext(r.Context())
        op.Logger.Info(fmt.Sprintf("Deleting %s", op.EntityType), "request_id", requestID, "id", id)

        // Delete item from database
        err := deleteFromDB(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                handleDatabaseError(w, r, err, "delete", op.EntityType, op.Logger)
                return
        }</span>

        <span class="cov8" title="1">op.Logger.Info(fmt.Sprintf("%s deleted successfully", op.EntityType),
                "request_id", requestID,
                "id", id)

        w.WriteHeader(http.StatusNoContent)

        // Record metrics
        recordCRUDMetric(op.Metrics, metricName, map[string]string{
                "status": "success",
        })</span>
}

// ExecuteUpdate performs a generic update operation.
func (op *CRUDOperation[T]) ExecuteUpdate(
        w http.ResponseWriter,
        r *http.Request,
        id uuid.UUID,
        parseRequest func(*http.Request) (interface{}, error),
        validateRequest func(interface{}) error,
        updateInDB func(context.Context, uuid.UUID, interface{}) (*T, error),
        toResponse func(*T) interface{},
        metricName string,
) <span class="cov8" title="1">{
        requestID := getRequestIDFromContext(r.Context())
        op.Logger.Info(fmt.Sprintf("Updating %s", op.EntityType), "request_id", requestID, "id", id)

        // Parse request body
        req, err := parseRequest(r)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, r, http.StatusBadRequest, err)
                return
        }</span>

        // Validate request
        <span class="cov8" title="1">if validateRequest != nil </span><span class="cov8" title="1">{
                if err := validateRequest(req); err != nil </span><span class="cov0" title="0">{
                        writeError(w, r, http.StatusBadRequest, err)
                        return
                }</span>
        }

        // Update item in database
        <span class="cov8" title="1">item, err := updateInDB(r.Context(), id, req)
        if err != nil </span><span class="cov0" title="0">{
                handleDatabaseError(w, r, err, "update", op.EntityType, op.Logger)
                return
        }</span>

        <span class="cov8" title="1">response := toResponse(item)

        op.Logger.Info(fmt.Sprintf("%s updated successfully", op.EntityType),
                "request_id", requestID,
                "id", id)

        writeJSON(w, r, http.StatusOK, response)

        // Record metrics
        recordCRUDMetric(op.Metrics, metricName, nil)</span>
}

// UpdateEntity is a generic helper to eliminate duplication in update operations.
func UpdateEntity[T any, R any](
        w http.ResponseWriter,
        r *http.Request,
        entityType string,
        logger *slog.Logger,
        metricsRegistry metrics.MetricsRegistry,
        parseAndConvert func(*http.Request) (interface{}, error),
        updateInDB func(context.Context, uuid.UUID, interface{}) (*T, error),
        toResponse func(*T) interface{},
        metricName string,
) <span class="cov8" title="1">{
        id, err := extractUUIDFromPath(r)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, r, http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov8" title="1">crudOp := &amp;CRUDOperation[T]{
                EntityType: entityType,
                Logger:     logger,
                Metrics:    metricsRegistry,
        }

        crudOp.ExecuteUpdate(w, r, id,
                parseAndConvert,
                func(req interface{}) error </span><span class="cov8" title="1">{
                        // Skip validation for now as we converted to DB format
                        return nil
                }</span>,
                updateInDB,
                toResponse,
                metricName)
}

// CreateEntity is a generic helper to eliminate duplication in create operations.
func CreateEntity[T any, R any](
        w http.ResponseWriter,
        r *http.Request,
        entityType string,
        logger *slog.Logger,
        metricsRegistry metrics.MetricsRegistry,
        parseAndConvert func(*http.Request) (interface{}, error),
        createInDB func(context.Context, interface{}) (*T, error),
        toResponse func(*T) interface{},
        metricName string,
) <span class="cov8" title="1">{
        requestID := getRequestIDFromContext(r.Context())
        logger.Info(fmt.Sprintf("Creating %s", entityType), "request_id", requestID)

        // Parse request body
        req, err := parseAndConvert(r)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, r, http.StatusBadRequest, err)
                return
        }</span>

        // Create item in database
        <span class="cov8" title="1">item, err := createInDB(r.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                handleDatabaseError(w, r, err, "create", entityType, logger)
                return
        }</span>

        <span class="cov8" title="1">response := toResponse(item)

        logger.Info(fmt.Sprintf("%s created successfully", entityType),
                "request_id", requestID)

        writeJSON(w, r, http.StatusCreated, response)

        // Record metrics
        recordCRUDMetric(metricsRegistry, metricName, nil)</span>
}

// JobControlOperation is a job control operation pattern for start/stop operations.
type JobControlOperation struct {
        EntityType string
        Logger     *slog.Logger
        Metrics    metrics.MetricsRegistry
}

// ExecuteStart performs a generic start operation.
func (op *JobControlOperation) ExecuteStart(
        w http.ResponseWriter,
        r *http.Request,
        id uuid.UUID,
        startInDB func(context.Context, uuid.UUID) error,
        getFromDB func(context.Context, uuid.UUID) (interface{}, error),
        toResponse func(interface{}) interface{},
        metricName string,
) <span class="cov8" title="1">{
        requestID := getRequestIDFromContext(r.Context())
        op.Logger.Info(fmt.Sprintf("Starting %s", op.EntityType), "request_id", requestID, "id", id)

        // Start execution
        err := startInDB(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                handleDatabaseError(w, r, err, "start", op.EntityType, op.Logger)
                return
        }</span>

        // Get updated status
        <span class="cov8" title="1">item, err := getFromDB(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                op.Logger.Error(fmt.Sprintf("Failed to get %s after start", op.EntityType),
                        "request_id", requestID, "id", id, "error", err)
                // Still return success since the job was started
        }</span>

        <span class="cov8" title="1">response := map[string]interface{}{
                "id":         id,
                "status":     "started",
                "message":    fmt.Sprintf("%s has been queued for execution", op.EntityType),
                "timestamp":  time.Now().UTC(),
                "request_id": requestID,
        }

        if item != nil </span><span class="cov8" title="1">{
                response[op.EntityType] = toResponse(item)
        }</span>

        <span class="cov8" title="1">op.Logger.Info(fmt.Sprintf("%s started successfully", op.EntityType),
                "request_id", requestID,
                "id", id)

        writeJSON(w, r, http.StatusOK, response)

        // Record metrics
        recordCRUDMetric(op.Metrics, metricName, nil)</span>
}

// ExecuteStop performs a generic stop operation.
func (op *JobControlOperation) ExecuteStop(
        w http.ResponseWriter,
        r *http.Request,
        id uuid.UUID,
        stopInDB func(context.Context, uuid.UUID) error,
        metricName string,
) <span class="cov8" title="1">{
        requestID := getRequestIDFromContext(r.Context())
        op.Logger.Info(fmt.Sprintf("Stopping %s", op.EntityType), "request_id", requestID, "id", id)

        // Stop execution
        err := stopInDB(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                handleDatabaseError(w, r, err, "stop", op.EntityType, op.Logger)
                return
        }</span>

        <span class="cov8" title="1">response := map[string]interface{}{
                "id":         id,
                "status":     "stopped",
                "message":    fmt.Sprintf("%s has been stopped", op.EntityType),
                "timestamp":  time.Now().UTC(),
                "request_id": requestID,
        }

        op.Logger.Info(fmt.Sprintf("%s stopped successfully", op.EntityType),
                "request_id", requestID,
                "id", id)

        writeJSON(w, r, http.StatusOK, response)

        // Record metrics
        recordCRUDMetric(op.Metrics, metricName, nil)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package handlers provides HTTP request handlers for the Scanorama API.
// This file implements discovery job management endpoints including CRUD operations,
// discovery execution control, and results retrieval.
package handlers

import (
        "context"
        "fmt"
        "log/slog"
        "net"
        "net/http"
        "time"

        "github.com/google/uuid"

        "github.com/anstrom/scanorama/internal/db"
        "github.com/anstrom/scanorama/internal/metrics"
)

// Validation constants.
const (
        maxDiscoveryNameLength = 255
        maxDescriptionLength   = 255
        maxPortsStringLength   = 50
        maxValidationErrors    = 100
        maxRetries             = 10
        maxTagLength           = 50
)

// DiscoveryHandler handles discovery-related API endpoints.
type DiscoveryHandler struct {
        database *db.DB
        logger   *slog.Logger
        metrics  *metrics.Registry
}

// NewDiscoveryHandler creates a new discovery handler.
func NewDiscoveryHandler(database *db.DB, logger *slog.Logger, metricsManager *metrics.Registry) *DiscoveryHandler <span class="cov0" title="0">{
        return &amp;DiscoveryHandler{
                database: database,
                logger:   logger.With("handler", "discovery"),
                metrics:  metricsManager,
        }
}</span>

// DiscoveryRequest represents a discovery job creation/update request.
type DiscoveryRequest struct {
        Name        string            `json:"name" validate:"required,min=1,max=255"`
        Description string            `json:"description,omitempty"`
        Networks    []string          `json:"networks" validate:"required,min=1"`
        Method      string            `json:"method" validate:"required,oneof=ping arp icmp tcp_connect"`
        Ports       string            `json:"ports,omitempty"`
        Timeout     time.Duration     `json:"timeout,omitempty"`
        Retries     int               `json:"retries,omitempty"`
        Options     map[string]string `json:"options,omitempty"`
        ScheduleID  *int64            `json:"schedule_id,omitempty"`
        Tags        []string          `json:"tags,omitempty"`
        Enabled     bool              `json:"enabled"`
}

// DiscoveryResponse represents a discovery job response.
type DiscoveryResponse struct {
        ID          int64             `json:"id"`
        Name        string            `json:"name"`
        Description string            `json:"description,omitempty"`
        Networks    []string          `json:"networks"`
        Method      string            `json:"method"`
        Ports       string            `json:"ports,omitempty"`
        Timeout     time.Duration     `json:"timeout,omitempty"`
        Retries     int               `json:"retries,omitempty"`
        Options     map[string]string `json:"options,omitempty"`
        ScheduleID  *int64            `json:"schedule_id,omitempty"`
        Tags        []string          `json:"tags,omitempty"`
        Enabled     bool              `json:"enabled"`
        Status      string            `json:"status"`
        Progress    float64           `json:"progress"`
        HostsFound  int               `json:"hosts_found"`
        LastRun     *time.Time        `json:"last_run,omitempty"`
        NextRun     *time.Time        `json:"next_run,omitempty"`
        RunCount    int               `json:"run_count"`
        ErrorCount  int               `json:"error_count"`
        LastError   string            `json:"last_error,omitempty"`
        CreatedAt   time.Time         `json:"created_at"`
        UpdatedAt   time.Time         `json:"updated_at"`
        CreatedBy   string            `json:"created_by,omitempty"`
}

// DiscoveryResultsResponse represents discovery results.
type DiscoveryResultsResponse struct {
        JobID       int64                  `json:"job_id"`
        TotalHosts  int                    `json:"total_hosts"`
        NewHosts    int                    `json:"new_hosts"`
        UpdatedAt   time.Time              `json:"updated_at"`
        Results     []DiscoveryResult      `json:"results"`
        Summary     map[string]interface{} `json:"summary"`
        GeneratedAt time.Time              `json:"generated_at"`
}

// DiscoveryResult represents an individual discovery result.
type DiscoveryResult struct {
        ID           int64     `json:"id"`
        HostIP       string    `json:"host_ip"`
        Hostname     string    `json:"hostname,omitempty"`
        MACAddress   string    `json:"mac_address,omitempty"`
        ResponseTime float64   `json:"response_time_ms"`
        Method       string    `json:"method"`
        IsNew        bool      `json:"is_new"`
        FirstSeen    time.Time `json:"first_seen"`
        LastSeen     time.Time `json:"last_seen"`
}

// ListDiscoveryJobs handles GET /api/v1/discovery - list discovery jobs with filtering and pagination.
func (h *DiscoveryHandler) ListDiscoveryJobs(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        listOp := &amp;ListOperation[*db.DiscoveryJob, db.DiscoveryFilters]{
                EntityType: "discovery jobs",
                MetricName: "api_discovery_jobs_listed_total",
                Logger:     h.logger,
                Metrics:    h.metrics,
                GetFilters: h.getDiscoveryFilters,
                ListFromDB: h.database.ListDiscoveryJobs,
                ToResponse: func(job *db.DiscoveryJob) interface{} </span><span class="cov0" title="0">{
                        return h.discoveryToResponse(job)
                }</span>,
        }
        <span class="cov0" title="0">listOp.Execute(w, r)</span>
}

// CreateDiscoveryJob handles POST /api/v1/discovery - create a new discovery job.
func (h *DiscoveryHandler) CreateDiscoveryJob(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        requestID := getRequestIDFromContext(r.Context())
        h.logger.Info("Creating discovery job", "request_id", requestID)

        // Parse request body
        var req DiscoveryRequest
        if err := parseJSON(r, &amp;req); err != nil </span><span class="cov0" title="0">{
                writeError(w, r, http.StatusBadRequest, err)
                return
        }</span>

        // Validate request
        <span class="cov0" title="0">if err := h.validateDiscoveryRequest(&amp;req); err != nil </span><span class="cov0" title="0">{
                writeError(w, r, http.StatusBadRequest, err)
                return
        }</span>

        // Create discovery job in database
        <span class="cov0" title="0">job, err := h.database.CreateDiscoveryJob(r.Context(), h.requestToDBDiscovery(&amp;req))
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to create discovery job", "request_id", requestID, "error", err)
                writeError(w, r, http.StatusInternalServerError,
                        fmt.Errorf("failed to create discovery job: %w", err))
                return
        }</span>

        <span class="cov0" title="0">response := h.discoveryToResponse(job)

        h.logger.Info("Discovery job created successfully",
                "request_id", requestID,
                "job_id", response.ID,
                "job_name", response.Name)

        writeJSON(w, r, http.StatusCreated, response)

        // Record metrics
        if h.metrics != nil </span><span class="cov0" title="0">{
                h.metrics.Counter("api_discovery_jobs_created_total", nil)
        }</span>
}

// GetDiscoveryJob handles GET /api/v1/discovery/{id} - get a discovery job.
func (h *DiscoveryHandler) GetDiscoveryJob(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        jobID, err := extractUUIDFromPath(r)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, r, http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov0" title="0">crudOp := &amp;CRUDOperation[db.DiscoveryJob]{
                EntityType: "discovery job",
                Logger:     h.logger,
                Metrics:    h.metrics,
        }

        crudOp.ExecuteGet(w, r, jobID,
                h.database.GetDiscoveryJob,
                func(job *db.DiscoveryJob) interface{} </span><span class="cov0" title="0">{
                        return h.discoveryToResponse(job)
                }</span>,
                "api_discovery_jobs_retrieved_total")
}

func (h *DiscoveryHandler) UpdateDiscoveryJob(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        UpdateEntity[db.DiscoveryJob, DiscoveryRequest](
                w, r,
                "discovery job",
                h.logger,
                h.metrics,
                func(r *http.Request) (interface{}, error) </span><span class="cov0" title="0">{
                        var req DiscoveryRequest
                        if err := parseJSON(r, &amp;req); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return h.requestToDBDiscovery(&amp;req), nil</span>
                },
                h.database.UpdateDiscoveryJob,
                func(job *db.DiscoveryJob) interface{} <span class="cov0" title="0">{
                        return h.discoveryToResponse(job)
                }</span>,
                "api_discovery_jobs_updated_total")
}

// DeleteDiscoveryJob handles DELETE /api/v1/discovery/{id} - delete a discovery job.
func (h *DiscoveryHandler) DeleteDiscoveryJob(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        jobID, err := extractUUIDFromPath(r)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, r, http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov0" title="0">crudOp := &amp;CRUDOperation[db.DiscoveryJob]{
                EntityType: "discovery job",
                Logger:     h.logger,
                Metrics:    h.metrics,
        }

        crudOp.ExecuteDelete(w, r, jobID, h.database.DeleteDiscoveryJob, "api_discovery_jobs_deleted_total")</span>
}

// StartDiscovery handles POST /api/v1/discovery/{id}/start - start a discovery job.
func (h *DiscoveryHandler) StartDiscovery(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        jobID, err := extractUUIDFromPath(r)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, r, http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov0" title="0">jobOp := &amp;JobControlOperation{
                EntityType: "discovery job",
                Logger:     h.logger,
                Metrics:    h.metrics,
        }

        jobOp.ExecuteStart(w, r, jobID, h.database.StartDiscoveryJob,
                func(ctx context.Context, id uuid.UUID) (interface{}, error) </span><span class="cov0" title="0">{
                        return h.database.GetDiscoveryJob(ctx, id)
                }</span>,
                func(item interface{}) interface{} <span class="cov0" title="0">{
                        if job, ok := item.(*db.DiscoveryJob); ok </span><span class="cov0" title="0">{
                                return h.discoveryToResponse(job)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }, "api_discovery_jobs_started_total")
}

// StopDiscovery handles POST /api/v1/discovery/{id}/stop - stop a running discovery job.
func (h *DiscoveryHandler) StopDiscovery(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        jobID, err := extractUUIDFromPath(r)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, r, http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov0" title="0">jobOp := &amp;JobControlOperation{
                EntityType: "discovery job",
                Logger:     h.logger,
                Metrics:    h.metrics,
        }

        jobOp.ExecuteStop(w, r, jobID, h.database.StopDiscoveryJob, "api_discovery_jobs_stopped_total")</span>
}

// Helper methods

// Helper methods

// validateDiscoveryRequest validates a discovery request.
func (h *DiscoveryHandler) validateDiscoveryRequest(req *DiscoveryRequest) error <span class="cov0" title="0">{
        if err := h.validateBasicFields(req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := h.validateMethod(req.Method); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := h.validateNetworks(req.Networks); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := h.validateLimits(req.Timeout, req.Retries); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return h.validateTags(req.Tags)</span>
}

func (h *DiscoveryHandler) validateBasicFields(req *DiscoveryRequest) error <span class="cov0" title="0">{
        if req.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("discovery job name is required")
        }</span>
        <span class="cov0" title="0">if len(req.Name) &gt; maxDiscoveryNameLength </span><span class="cov0" title="0">{
                return fmt.Errorf("discovery job name too long (max %d characters)", maxDiscoveryNameLength)
        }</span>
        <span class="cov0" title="0">if len(req.Networks) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("at least one network is required")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (h *DiscoveryHandler) validateMethod(method string) error <span class="cov0" title="0">{
        validMethods := map[string]bool{
                "ping":        true,
                "arp":         true,
                "icmp":        true,
                "tcp_connect": true,
        }
        if !validMethods[method] </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid discovery method: %s", method)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (h *DiscoveryHandler) validateNetworks(networks []string) error <span class="cov0" title="0">{
        for i, network := range networks </span><span class="cov0" title="0">{
                if network == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("network %d is empty", i+1)
                }</span>
                // Try to parse as CIDR first
                <span class="cov0" title="0">if _, _, err := net.ParseCIDR(network); err != nil </span><span class="cov0" title="0">{
                        // Try to parse as single IP
                        if net.ParseIP(network) == nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("network %d has invalid format: %s", i+1, network)
                        }</span>
                }
                <span class="cov0" title="0">if len(network) &gt; maxDescriptionLength </span><span class="cov0" title="0">{
                        return fmt.Errorf("network %d too long (max %d characters)", i+1, maxDescriptionLength)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (h *DiscoveryHandler) validateLimits(timeout time.Duration, retries int) error <span class="cov0" title="0">{
        if timeout &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("timeout cannot be negative")
        }</span>
        <span class="cov0" title="0">if retries &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("retries cannot be negative")
        }</span>
        <span class="cov0" title="0">if retries &gt; maxRetries </span><span class="cov0" title="0">{
                return fmt.Errorf("too many retries (max %d)", maxRetries)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (h *DiscoveryHandler) validateTags(tags []string) error <span class="cov0" title="0">{
        for i, tag := range tags </span><span class="cov0" title="0">{
                if tag == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("tag %d is empty", i+1)
                }</span>
                <span class="cov0" title="0">if len(tag) &gt; maxTagLength </span><span class="cov0" title="0">{
                        return fmt.Errorf("tag %d too long (max %d characters)", i+1, maxTagLength)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// getDiscoveryFilters extracts filter parameters from request.
func (h *DiscoveryHandler) getDiscoveryFilters(r *http.Request) db.DiscoveryFilters <span class="cov0" title="0">{
        filters := db.DiscoveryFilters{}

        if status := r.URL.Query().Get("status"); status != "" </span><span class="cov0" title="0">{
                filters.Status = status
        }</span>

        <span class="cov0" title="0">if method := r.URL.Query().Get("method"); method != "" </span><span class="cov0" title="0">{
                filters.Method = method
        }</span>

        <span class="cov0" title="0">return filters</span>
}

// requestToDBDiscovery converts a discovery request to database discovery object.
func (h *DiscoveryHandler) requestToDBDiscovery(req *DiscoveryRequest) interface{} <span class="cov0" title="0">{
        // This should return the appropriate database discovery type
        // The exact structure would depend on the database package implementation
        return map[string]interface{}{
                "name":        req.Name,
                "description": req.Description,
                "networks":    req.Networks,
                "method":      req.Method,
                "ports":       req.Ports,
                "timeout":     req.Timeout,
                "retries":     req.Retries,
                "options":     req.Options,
                "schedule_id": req.ScheduleID,
                "tags":        req.Tags,
                "enabled":     req.Enabled,
                "status":      "pending",
                "created_at":  time.Now().UTC(),
                "updated_at":  time.Now().UTC(),
        }
}</span>

// discoveryToResponse converts a database discovery job to response format.
func (h *DiscoveryHandler) discoveryToResponse(_ interface{}) DiscoveryResponse <span class="cov0" title="0">{
        // This would convert from the actual database discovery type
        // For now, return a placeholder structure
        return DiscoveryResponse{
                ID:          1,                // job.ID
                Name:        "",               // job.Name
                Description: "",               // job.Description
                Networks:    []string{},       // job.Networks
                Method:      "ping",           // job.Method
                Enabled:     true,             // job.Enabled
                Status:      "pending",        // job.Status
                Progress:    0.0,              // job.Progress
                HostsFound:  0,                // job.HostsFound
                RunCount:    0,                // job.RunCount
                ErrorCount:  0,                // job.ErrorCount
                CreatedAt:   time.Now().UTC(), // job.CreatedAt
                UpdatedAt:   time.Now().UTC(), // job.UpdatedAt
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package handlers provides HTTP request handlers for the Scanorama API.
// This file implements health check and system status endpoints.
package handlers

import (
        "context"
        "encoding/json"
        "fmt"
        "log/slog"
        "net/http"
        "os"
        "runtime"
        "strings"
        "time"

        "github.com/anstrom/scanorama/internal/metrics"
)

// DatabasePinger defines the interface for database health checking.
type DatabasePinger interface {
        Ping(ctx context.Context) error
}

// Timeout constants.
const (
        healthCheckTimeout = 5 * time.Second
        readinessTimeout   = 10 * time.Second
        dependencyTimeout  = 3 * time.Second
)

// Status constants.
const (
        StatusHealthy       = "healthy"
        StatusUnhealthy     = "unhealthy"
        StatusNotConfigured = "not configured"
)

// HealthHandler handles health check and status endpoints.
type HealthHandler struct {
        database  DatabasePinger
        logger    *slog.Logger
        metrics   metrics.MetricsRegistry
        startTime time.Time
}

// NewHealthHandler creates a new health handler.
func NewHealthHandler(database DatabasePinger, logger *slog.Logger, metricsManager metrics.MetricsRegistry) *HealthHandler <span class="cov8" title="1">{
        return &amp;HealthHandler{
                database:  database,
                logger:    logger.With("handler", "health"),
                metrics:   metricsManager,
                startTime: time.Now(),
        }
}</span>

// HealthResponse represents a health check response.
type HealthResponse struct {
        Status    string            `json:"status"`
        Timestamp time.Time         `json:"timestamp"`
        Uptime    string            `json:"uptime"`
        Checks    map[string]string `json:"checks"`
}

// StatusResponse represents a detailed status response.
type StatusResponse struct {
        Service   ServiceInfo    `json:"service"`
        System    SystemInfo     `json:"system"`
        Database  DatabaseInfo   `json:"database"`
        Metrics   MetricsInfo    `json:"metrics"`
        Health    HealthResponse `json:"health"`
        Timestamp time.Time      `json:"timestamp"`
}

// ServiceInfo contains service-related information.
type ServiceInfo struct {
        Name      string    `json:"name"`
        Version   string    `json:"version"`
        StartTime time.Time `json:"start_time"`
        Uptime    string    `json:"uptime"`
        PID       int       `json:"pid"`
}

// SystemInfo contains system-related information.
type SystemInfo struct {
        OS           string            `json:"os"`
        Architecture string            `json:"architecture"`
        CPUs         int               `json:"cpus"`
        GoVersion    string            `json:"go_version"`
        Memory       MemoryInfo        `json:"memory"`
        Goroutines   int               `json:"goroutines"`
        Environment  map[string]string `json:"environment,omitempty"`
}

// MemoryInfo contains memory usage information.
type MemoryInfo struct {
        Allocated   uint64 `json:"allocated_bytes"`
        TotalAlloc  uint64 `json:"total_alloc_bytes"`
        System      uint64 `json:"system_bytes"`
        GCCycles    uint32 `json:"gc_cycles"`
        LastGC      string `json:"last_gc"`
        HeapObjects uint64 `json:"heap_objects"`
}

// DatabaseInfo contains database connection information.
type DatabaseInfo struct {
        Connected    bool          `json:"connected"`
        Driver       string        `json:"driver"`
        Host         string        `json:"host"`
        Database     string        `json:"database"`
        LastPing     time.Time     `json:"last_ping"`
        ResponseTime time.Duration `json:"response_time_ms"`
        Error        string        `json:"error,omitempty"`
}

// MetricsInfo contains metrics system information.
type MetricsInfo struct {
        Enabled       bool                   `json:"enabled"`
        TotalCounters int                    `json:"total_counters"`
        TotalGauges   int                    `json:"total_gauges"`
        TotalHistos   int                    `json:"total_histograms"`
        LastUpdated   time.Time              `json:"last_updated"`
        Summary       map[string]interface{} `json:"summary,omitempty"`
}

// VersionResponse represents version information.
type VersionResponse struct {
        Version   string    `json:"version"`
        Commit    string    `json:"commit"`
        BuildTime string    `json:"build_time"`
        GoVersion string    `json:"go_version"`
        Timestamp time.Time `json:"timestamp"`
}

// Health performs a basic health check.
func (h *HealthHandler) Health(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(r.Context(), healthCheckTimeout)
        defer cancel()

        h.logger.Debug("Health check requested", "remote_addr", r.RemoteAddr)

        response := HealthResponse{
                Status:    StatusHealthy,
                Timestamp: time.Now().UTC(),
                Uptime:    time.Since(h.startTime).String(),
                Checks:    make(map[string]string),
        }

        // Check database connectivity
        if h.database != nil </span><span class="cov8" title="1">{
                if err := h.database.Ping(ctx); err != nil </span><span class="cov8" title="1">{
                        response.Status = StatusUnhealthy
                        response.Checks["database"] = "failed: " + err.Error()
                        h.logger.Warn("Database health check failed", "error", err)
                }</span> else<span class="cov8" title="1"> {
                        response.Checks["database"] = "ok"
                }</span>
        } else<span class="cov8" title="1"> {
                response.Checks["database"] = StatusNotConfigured
        }</span>

        // Check metrics system
        <span class="cov8" title="1">if h.metrics != nil </span><span class="cov8" title="1">{
                response.Checks["metrics"] = "ok"
        }</span> else<span class="cov0" title="0"> {
                response.Checks["metrics"] = StatusNotConfigured
        }</span>

        // Set HTTP status based on health
        <span class="cov8" title="1">statusCode := http.StatusOK
        if response.Status == StatusUnhealthy </span><span class="cov8" title="1">{
                statusCode = http.StatusServiceUnavailable
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)

        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to encode health response", "error", err)
                return
        }</span>

        // Record metrics
        <span class="cov8" title="1">if h.metrics != nil </span><span class="cov8" title="1">{
                h.metrics.Counter("api_health_checks_total", metrics.Labels{
                        "status": response.Status,
                })
        }</span>
}

// Status provides detailed system status information.
func (h *HealthHandler) Status(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(r.Context(), readinessTimeout)
        defer cancel()

        h.logger.Debug("Status check requested", "remote_addr", r.RemoteAddr)

        response := StatusResponse{
                Timestamp: time.Now().UTC(),
        }

        // Service information
        response.Service = ServiceInfo{
                Name:      "scanorama",
                Version:   getVersion(),
                StartTime: h.startTime,
                Uptime:    time.Since(h.startTime).String(),
                PID:       getPID(),
        }

        // System information
        response.System = h.getSystemInfo()

        // Database information
        response.Database = h.getDatabaseInfo(ctx)

        // Metrics information
        response.Metrics = h.getMetricsInfo()

        // Health check
        dbCtx, dbCancel := context.WithTimeout(ctx, dependencyTimeout)
        defer dbCancel()
        response.Health = h.getHealthInfo(dbCtx)

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)

        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to encode status response", "error", err)
                return
        }</span>

        // Record metrics
        <span class="cov0" title="0">if h.metrics != nil </span><span class="cov0" title="0">{
                h.metrics.Counter("api_status_checks_total", metrics.Labels{
                        "status": response.Health.Status,
                })
        }</span>
}

// Version provides version information.
func (h *HealthHandler) Version(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        h.logger.Debug("Version requested", "remote_addr", r.RemoteAddr)

        response := VersionResponse{
                Version:   getVersion(),
                Commit:    getCommit(),
                BuildTime: getBuildTime(),
                GoVersion: runtime.Version(),
                Timestamp: time.Now().UTC(),
        }

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)

        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to encode version response", "error", err)
                return
        }</span>

        // Record metrics
        <span class="cov0" title="0">if h.metrics != nil </span><span class="cov0" title="0">{
                h.metrics.Counter("api_version_requests_total", nil)
        }</span>
}

// Metrics provides metrics endpoint (Prometheus format).
func (h *HealthHandler) Metrics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        h.logger.Debug("Metrics requested", "remote_addr", r.RemoteAddr)

        if h.metrics == nil </span><span class="cov0" title="0">{
                http.Error(w, "Metrics not available", http.StatusNotFound)
                return
        }</span>

        // Export metrics in simple format (Prometheus format would need additional implementation)
        <span class="cov0" title="0">metricsData := h.metrics.GetMetrics()
        w.Header().Set("Content-Type", "text/plain")
        for _, metric := range metricsData </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintf(w, "# TYPE %s %s\n", metric.Name, string(metric.Type))
                labelStr := ""
                if len(metric.Labels) &gt; 0 </span><span class="cov0" title="0">{
                        labelParts := make([]string, 0, len(metric.Labels))
                        for k, v := range metric.Labels </span><span class="cov0" title="0">{
                                labelParts = append(labelParts, fmt.Sprintf("%s=%q", k, v))
                        }</span>
                        <span class="cov0" title="0">labelStr = "{" + strings.Join(labelParts, ",") + "}"</span>
                }
                <span class="cov0" title="0">_, _ = fmt.Fprintf(w, "%s%s %g %d\n", metric.Name, labelStr, metric.Value, metric.Timestamp.Unix())</span>
        }

        // Record metrics (don't count this in the metrics to avoid recursion)
}

// getSystemInfo gathers system information.
func (h *HealthHandler) getSystemInfo() SystemInfo <span class="cov0" title="0">{
        var memStats runtime.MemStats
        runtime.ReadMemStats(&amp;memStats)

        memInfo := MemoryInfo{
                Allocated:   memStats.Alloc,
                TotalAlloc:  memStats.TotalAlloc,
                System:      memStats.Sys,
                GCCycles:    memStats.NumGC,
                HeapObjects: memStats.HeapObjects,
        }

        if memStats.LastGC &gt; 0 </span><span class="cov0" title="0">{
                // Safely convert uint64 to int64 for time.Unix
                // LastGC is in nanoseconds, so we need to handle potential overflow
                const maxInt64 = 9223372036854775807 // math.MaxInt64
                if memStats.LastGC &lt;= maxInt64 </span><span class="cov0" title="0">{
                        memInfo.LastGC = time.Unix(0, int64(memStats.LastGC)).Format(time.RFC3339)
                }</span> else<span class="cov0" title="0"> {
                        // If overflow would occur, use current time as fallback
                        memInfo.LastGC = time.Now().Format(time.RFC3339)
                }</span>
        }

        <span class="cov0" title="0">return SystemInfo{
                OS:           runtime.GOOS,
                Architecture: runtime.GOARCH,
                CPUs:         runtime.NumCPU(),
                GoVersion:    runtime.Version(),
                Memory:       memInfo,
                Goroutines:   runtime.NumGoroutine(),
        }</span>
}

// getDatabaseInfo gathers database information.
func (h *HealthHandler) getDatabaseInfo(ctx context.Context) DatabaseInfo <span class="cov0" title="0">{
        info := DatabaseInfo{
                Connected: false,
                Driver:    "postgres",
        }

        if h.database == nil </span><span class="cov0" title="0">{
                info.Error = "database not configured"
                return info
        }</span>

        // Get database configuration info if available
        // Note: We should not expose sensitive connection details
        <span class="cov0" title="0">info.Host = "configured"
        info.Database = "configured"

        // Test connection with timing
        start := time.Now()
        if err := h.database.Ping(ctx); err != nil </span><span class="cov0" title="0">{
                info.Error = err.Error()
                info.ResponseTime = time.Since(start)
                return info
        }</span>

        <span class="cov0" title="0">info.Connected = true
        info.LastPing = time.Now().UTC()
        info.ResponseTime = time.Since(start)

        return info</span>
}

// getMetricsInfo gathers metrics system information.
func (h *HealthHandler) getMetricsInfo() MetricsInfo <span class="cov0" title="0">{
        info := MetricsInfo{
                Enabled:     h.metrics != nil,
                LastUpdated: time.Now().UTC(),
        }

        if h.metrics != nil </span><span class="cov0" title="0">{
                // Get metrics summary
                allMetrics := h.metrics.GetMetrics()
                counterCount := 0
                gaugeCount := 0
                histogramCount := 0

                for _, metric := range allMetrics </span><span class="cov0" title="0">{
                        switch metric.Type </span>{
                        case metrics.TypeCounter:<span class="cov0" title="0">
                                counterCount++</span>
                        case metrics.TypeGauge:<span class="cov0" title="0">
                                gaugeCount++</span>
                        case metrics.TypeHistogram:<span class="cov0" title="0">
                                histogramCount++</span>
                        }
                }

                <span class="cov0" title="0">info.TotalCounters = counterCount
                info.TotalGauges = gaugeCount
                info.TotalHistos = histogramCount
                info.Summary = map[string]interface{}{
                        "total_metrics": len(allMetrics),
                        "last_updated":  time.Now().UTC(),
                }</span>
        }

        <span class="cov0" title="0">return info</span>
}

// getHealthInfo performs health checks and returns status.
func (h *HealthHandler) getHealthInfo(ctx context.Context) HealthResponse <span class="cov0" title="0">{
        response := HealthResponse{
                Status:    "healthy",
                Timestamp: time.Now().UTC(),
                Uptime:    time.Since(h.startTime).String(),
                Checks:    make(map[string]string),
        }

        // Database health check
        if h.database != nil </span><span class="cov0" title="0">{
                if err := h.database.Ping(ctx); err != nil </span><span class="cov0" title="0">{
                        response.Status = StatusUnhealthy
                        response.Checks["database"] = "failed: " + err.Error()
                }</span> else<span class="cov0" title="0"> {
                        response.Checks["database"] = "ok"
                }</span>
        } else<span class="cov0" title="0"> {
                response.Checks["database"] = StatusNotConfigured
        }</span>

        // Memory health check
        <span class="cov0" title="0">var memStats runtime.MemStats
        runtime.ReadMemStats(&amp;memStats)

        // Check if memory usage is excessive (over 1GB allocated)
        const maxMemory = 1 &lt;&lt; 30 // 1GB
        if memStats.Alloc &gt; maxMemory </span><span class="cov0" title="0">{
                response.Status = "degraded"
                response.Checks["memory"] = "high usage"
        }</span> else<span class="cov0" title="0"> {
                response.Checks["memory"] = "ok"
        }</span>

        // Goroutine health check
        <span class="cov0" title="0">goroutines := runtime.NumGoroutine()
        const maxGoroutines = 1000
        if goroutines &gt; maxGoroutines </span><span class="cov0" title="0">{
                if response.Status == StatusHealthy </span><span class="cov0" title="0">{
                        response.Status = "degraded"
                }</span>
                <span class="cov0" title="0">response.Checks["goroutines"] = "high count"</span>
        } else<span class="cov0" title="0"> {
                response.Checks["goroutines"] = "ok"
        }</span>

        <span class="cov0" title="0">return response</span>
}

// Helper functions for build information (these should be set via ldflags).
var (
        version   = "dev"
        commit    = "none"
        buildTime = "unknown"
)

func getVersion() string <span class="cov0" title="0">{
        return version
}</span>

func getCommit() string <span class="cov0" title="0">{
        return commit
}</span>

func getBuildTime() string <span class="cov0" title="0">{
        return buildTime
}</span>

func getPID() int <span class="cov0" title="0">{
        return os.Getpid()
}</span>

// SetBuildInfo sets build information (called by main package).
func SetBuildInfo(v, c, bt string) <span class="cov0" title="0">{
        version = v
        commit = c
        buildTime = bt
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package handlers provides HTTP request handlers for the Scanorama API.
// This file implements host management endpoints including CRUD operations
// and host-related scan retrieval.
package handlers

import (
        "fmt"
        "log/slog"
        "net"
        "net/http"
        "time"

        "github.com/anstrom/scanorama/internal/db"
        "github.com/anstrom/scanorama/internal/errors"
        "github.com/anstrom/scanorama/internal/metrics"
)

// Validation constants for host fields.
const (
        maxHostnameLength        = 255
        maxHostDescriptionLength = 1000
        maxOSInfoLength          = 100
        maxOSVersionLength       = 100
        maxServicesLength        = 100
        maxHostTagCount          = 100
        maxHostTagLength         = 50
        maxHostMetadataKeys      = 50
)

// HostHandler handles host-related API endpoints.
type HostHandler struct {
        database *db.DB
        logger   *slog.Logger
        metrics  *metrics.Registry
}

// NewHostHandler creates a new host handler.
func NewHostHandler(database *db.DB, logger *slog.Logger, metricsManager *metrics.Registry) *HostHandler <span class="cov0" title="0">{
        return &amp;HostHandler{
                database: database,
                logger:   logger.With("handler", "host"),
                metrics:  metricsManager,
        }
}</span>

// HostRequest represents a host creation/update request.
type HostRequest struct {
        IP          string            `json:"ip" validate:"required,ip"`
        Hostname    string            `json:"hostname,omitempty"`
        Description string            `json:"description,omitempty"`
        OS          string            `json:"os,omitempty"`
        OSVersion   string            `json:"os_version,omitempty"`
        Tags        []string          `json:"tags,omitempty"`
        Metadata    map[string]string `json:"metadata,omitempty"`
        Active      bool              `json:"active"`
}

// HostResponse represents a host response.
type HostResponse struct {
        ID           int64             `json:"id"`
        IP           string            `json:"ip"`
        Hostname     string            `json:"hostname,omitempty"`
        Description  string            `json:"description,omitempty"`
        OS           string            `json:"os,omitempty"`
        OSVersion    string            `json:"os_version,omitempty"`
        Tags         []string          `json:"tags,omitempty"`
        Metadata     map[string]string `json:"metadata,omitempty"`
        Active       bool              `json:"active"`
        LastSeen     *time.Time        `json:"last_seen,omitempty"`
        LastScanID   *int64            `json:"last_scan_id,omitempty"`
        ScanCount    int               `json:"scan_count"`
        OpenPorts    int               `json:"open_ports"`
        TotalPorts   int               `json:"total_ports"`
        CreatedAt    time.Time         `json:"created_at"`
        UpdatedAt    time.Time         `json:"updated_at"`
        DiscoveredBy string            `json:"discovered_by,omitempty"`
}

// HostScanResponse represents a scan associated with a host.
type HostScanResponse struct {
        ID        int64      `json:"id"`
        Name      string     `json:"name"`
        ScanType  string     `json:"scan_type"`
        Status    string     `json:"status"`
        Progress  float64    `json:"progress"`
        StartTime *time.Time `json:"start_time,omitempty"`
        EndTime   *time.Time `json:"end_time,omitempty"`
        Duration  *string    `json:"duration,omitempty"`
        CreatedAt time.Time  `json:"created_at"`
}

// ListHosts handles GET /api/v1/hosts - list all hosts with pagination.
func (h *HostHandler) ListHosts(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        listOp := &amp;ListOperation[*db.Host, db.HostFilters]{
                EntityType: "hosts",
                MetricName: "api_hosts_listed_total",
                Logger:     h.logger,
                Metrics:    h.metrics,
                GetFilters: h.getHostFilters,
                ListFromDB: h.database.ListHosts,
                ToResponse: func(host *db.Host) interface{} </span><span class="cov0" title="0">{
                        return h.hostToResponse(host)
                }</span>,
        }
        <span class="cov0" title="0">listOp.Execute(w, r)</span>
}

// CreateHost handles POST /api/v1/hosts - create a new host.
func (h *HostHandler) CreateHost(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        requestID := getRequestIDFromContext(r.Context())
        h.logger.Info("Creating host", "request_id", requestID)

        // Parse request body
        var req HostRequest
        if err := parseJSON(r, &amp;req); err != nil </span><span class="cov0" title="0">{
                writeError(w, r, http.StatusBadRequest, err)
                return
        }</span>

        // Validate request
        <span class="cov0" title="0">if err := h.validateHostRequest(&amp;req); err != nil </span><span class="cov0" title="0">{
                writeError(w, r, http.StatusBadRequest, err)
                return
        }</span>

        // Create host in database
        <span class="cov0" title="0">host, err := h.database.CreateHost(r.Context(), h.requestToDBHost(&amp;req))
        if err != nil </span><span class="cov0" title="0">{
                if errors.IsConflict(err) </span><span class="cov0" title="0">{
                        writeError(w, r, http.StatusConflict,
                                fmt.Errorf("host with IP %s already exists", req.IP))
                        return
                }</span>
                <span class="cov0" title="0">h.logger.Error("Failed to create host", "request_id", requestID, "error", err)
                writeError(w, r, http.StatusInternalServerError,
                        fmt.Errorf("failed to create host: %w", err))
                return</span>
        }

        <span class="cov0" title="0">response := h.hostToResponse(host)

        h.logger.Info("Host created successfully",
                "request_id", requestID,
                "host_id", response.ID,
                "host_ip", response.IP)

        writeJSON(w, r, http.StatusCreated, response)

        // Record metrics
        if h.metrics != nil </span><span class="cov0" title="0">{
                h.metrics.Counter("api_hosts_created_total", nil)
        }</span>
}

// GetHost handles GET /api/v1/hosts/{id} - get a specific host.
func (h *HostHandler) GetHost(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hostID, err := extractUUIDFromPath(r)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, r, http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov0" title="0">crudOp := &amp;CRUDOperation[db.Host]{
                EntityType: "host",
                Logger:     h.logger,
                Metrics:    h.metrics,
        }

        crudOp.ExecuteGet(w, r, hostID,
                h.database.GetHost,
                func(host *db.Host) interface{} </span><span class="cov0" title="0">{
                        return h.hostToResponse(host)
                }</span>,
                "api_hosts_retrieved_total")
}

// UpdateHost handles PUT /api/v1/hosts/{id} - update a host.
func (h *HostHandler) UpdateHost(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        UpdateEntity[db.Host, HostRequest](
                w, r,
                "host",
                h.logger,
                h.metrics,
                func(r *http.Request) (interface{}, error) </span><span class="cov0" title="0">{
                        var req HostRequest
                        if err := parseJSON(r, &amp;req); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return h.requestToDBHost(&amp;req), nil</span>
                },
                h.database.UpdateHost,
                func(host *db.Host) interface{} <span class="cov0" title="0">{
                        return h.hostToResponse(host)
                }</span>,
                "api_hosts_updated_total")
}

// DeleteHost handles DELETE /api/v1/hosts/{id} - delete a host.
func (h *HostHandler) DeleteHost(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hostID, err := extractUUIDFromPath(r)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, r, http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov0" title="0">crudOp := &amp;CRUDOperation[db.Host]{
                EntityType: "host",
                Logger:     h.logger,
                Metrics:    h.metrics,
        }

        crudOp.ExecuteDelete(w, r, hostID, h.database.DeleteHost, "api_hosts_deleted_total")</span>
}

// GetHostScans handles GET /api/v1/hosts/{id}/scans - get scans for a specific host.
func (h *HostHandler) GetHostScans(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        requestID := getRequestIDFromContext(r.Context())

        // Extract host ID from URL
        hostID, err := extractUUIDFromPath(r)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, r, http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Getting host scans", "request_id", requestID, "host_id", hostID)

        // Parse pagination parameters
        params, err := getPaginationParams(r)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, r, http.StatusBadRequest, err)
                return
        }</span>

        // Parse filter parameters
        <span class="cov0" title="0">filters := h.getScanFilters(r)
        filters["host_id"] = hostID

        // Get host scans from database
        scans, total, err := h.database.GetHostScans(r.Context(), hostID, params.Offset, params.PageSize)
        if err != nil </span><span class="cov0" title="0">{
                if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        writeError(w, r, http.StatusNotFound,
                                fmt.Errorf("host not found"))
                        return
                }</span>
                <span class="cov0" title="0">h.logger.Error("Failed to get host scans", "request_id", requestID, "host_id", hostID, "error", err)
                writeError(w, r, http.StatusInternalServerError,
                        fmt.Errorf("failed to retrieve host scans: %w", err))
                return</span>
        }

        // Convert to response format
        <span class="cov0" title="0">responses := make([]HostScanResponse, len(scans))
        for i, scan := range scans </span><span class="cov0" title="0">{
                responses[i] = h.scanToHostScanResponse(scan)
        }</span>

        // Write paginated response
        <span class="cov0" title="0">writePaginatedResponse(w, r, responses, params, total)

        // Record metrics
        if h.metrics != nil </span><span class="cov0" title="0">{
                h.metrics.Counter("api_host_scans_retrieved_total", nil)
        }</span>
}

// Helper methods

// validateHostRequest validates a host request.
func (h *HostHandler) validateHostRequest(req *HostRequest) error <span class="cov0" title="0">{
        if req.IP == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("host IP is required")
        }</span>

        // Basic IP format validation
        <span class="cov0" title="0">if net.ParseIP(req.IP) == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid IP address format: %s", req.IP)
        }</span>

        <span class="cov0" title="0">if len(req.Hostname) &gt; maxHostnameLength </span><span class="cov0" title="0">{
                return fmt.Errorf("hostname too long (max %d characters)", maxHostnameLength)
        }</span>

        <span class="cov0" title="0">if len(req.Description) &gt; maxHostDescriptionLength </span><span class="cov0" title="0">{
                return fmt.Errorf("description too long (max %d characters)", maxHostDescriptionLength)
        }</span>

        <span class="cov0" title="0">if len(req.OS) &gt; maxOSInfoLength </span><span class="cov0" title="0">{
                return fmt.Errorf("OS info too long (max %d characters)", maxOSInfoLength)
        }</span>

        <span class="cov0" title="0">if len(req.OSVersion) &gt; maxOSVersionLength </span><span class="cov0" title="0">{
                return fmt.Errorf("OS version field too long (max %d characters)", maxOSVersionLength)
        }</span>

        // Validate tags
        <span class="cov0" title="0">for i, tag := range req.Tags </span><span class="cov0" title="0">{
                if tag == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("tag %d is empty", i+1)
                }</span>
                <span class="cov0" title="0">if len(tag) &gt; maxHostTagLength </span><span class="cov0" title="0">{
                        return fmt.Errorf("tag %d too long (max %d characters)", i+1, maxHostTagLength)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// getHostFilters extracts filter parameters from request.
func (h *HostHandler) getHostFilters(r *http.Request) db.HostFilters <span class="cov0" title="0">{
        filters := db.HostFilters{}

        if os := r.URL.Query().Get("os"); os != "" </span><span class="cov0" title="0">{
                filters.OSFamily = os
        }</span>

        <span class="cov0" title="0">if status := r.URL.Query().Get("status"); status != "" </span><span class="cov0" title="0">{
                filters.Status = status
        }</span>

        <span class="cov0" title="0">if network := r.URL.Query().Get("network"); network != "" </span><span class="cov0" title="0">{
                filters.Network = network
        }</span>

        <span class="cov0" title="0">return filters</span>
}

// getScanFilters extracts scan filter parameters from request.
func (h *HostHandler) getScanFilters(r *http.Request) map[string]interface{} <span class="cov0" title="0">{
        filters := make(map[string]interface{})

        if status := r.URL.Query().Get("status"); status != "" </span><span class="cov0" title="0">{
                filters["status"] = status
        }</span>

        <span class="cov0" title="0">if scanType := r.URL.Query().Get("scan_type"); scanType != "" </span><span class="cov0" title="0">{
                filters["scan_type"] = scanType
        }</span>

        <span class="cov0" title="0">if createdAfter := r.URL.Query().Get("created_after"); createdAfter != "" </span><span class="cov0" title="0">{
                if timestamp, err := time.Parse(time.RFC3339, createdAfter); err == nil </span><span class="cov0" title="0">{
                        filters["created_after"] = timestamp
                }</span>
        }

        <span class="cov0" title="0">if createdBefore := r.URL.Query().Get("created_before"); createdBefore != "" </span><span class="cov0" title="0">{
                if timestamp, err := time.Parse(time.RFC3339, createdBefore); err == nil </span><span class="cov0" title="0">{
                        filters["created_before"] = timestamp
                }</span>
        }

        <span class="cov0" title="0">return filters</span>
}

// requestToDBHost converts a host request to database host object.
func (h *HostHandler) requestToDBHost(req *HostRequest) interface{} <span class="cov0" title="0">{
        // This should return the appropriate database host type
        // The exact structure would depend on the database package implementation
        return map[string]interface{}{
                "ip":          req.IP,
                "hostname":    req.Hostname,
                "description": req.Description,
                "os":          req.OS,
                "os_version":  req.OSVersion,
                "tags":        req.Tags,
                "metadata":    req.Metadata,
                "active":      req.Active,
                "created_at":  time.Now().UTC(),
                "updated_at":  time.Now().UTC(),
        }
}</span>

// hostToResponse converts a database host to response format.
func (h *HostHandler) hostToResponse(_ interface{}) HostResponse <span class="cov0" title="0">{
        // This would convert from the actual database host type
        // For now, return a placeholder structure
        return HostResponse{
                ID:          1,                   // host.ID
                IP:          "127.0.0.1",         // host.IP
                Hostname:    "",                  // host.Hostname
                Description: "",                  // host.Description
                OS:          "",                  // host.OS
                OSVersion:   "",                  // host.OSVersion
                Tags:        []string{},          // host.Tags
                Metadata:    map[string]string{}, // host.Metadata
                Active:      true,                // host.Active
                ScanCount:   0,                   // host.ScanCount
                OpenPorts:   0,                   // host.OpenPorts
                TotalPorts:  0,                   // host.TotalPorts
                CreatedAt:   time.Now().UTC(),    // host.CreatedAt
                UpdatedAt:   time.Now().UTC(),    // host.UpdatedAt
        }
}</span>

// scanToHostScanResponse converts a scan to host scan response format.
func (h *HostHandler) scanToHostScanResponse(_ interface{}) HostScanResponse <span class="cov0" title="0">{
        // This would convert from the actual database scan type
        // For now, return a placeholder structure
        return HostScanResponse{
                ID:        1,                // scan.ID
                Name:      "",               // scan.Name
                ScanType:  "",               // scan.ScanType
                Status:    "pending",        // scan.Status
                Progress:  0.0,              // scan.Progress
                CreatedAt: time.Now().UTC(), // scan.CreatedAt
        }
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package handlers provides HTTP request handlers for the Scanorama API.
// This package implements REST endpoint handlers for scanning, discovery,
// host management, and administrative operations.
package handlers

import (
        "log/slog"
        "net/http"

        "github.com/anstrom/scanorama/internal/db"
        "github.com/anstrom/scanorama/internal/metrics"
)

// HandlerManager manages all API handlers and their dependencies.
type HandlerManager struct {
        database *db.DB
        logger   *slog.Logger
        metrics  *metrics.Registry

        // Individual handler groups
        health    *HealthHandler
        scan      *ScanHandler
        host      *HostHandler
        discovery *DiscoveryHandler
        profile   *ProfileHandler
        schedule  *ScheduleHandler
        admin     *AdminHandler
        websocket *WebSocketHandler
}

// New creates a new handler manager with all handler groups initialized.
func New(database *db.DB, logger *slog.Logger, metricsManager *metrics.Registry) *HandlerManager <span class="cov0" title="0">{
        hm := &amp;HandlerManager{
                database: database,
                logger:   logger,
                metrics:  metricsManager,
        }

        // Initialize individual handler groups
        hm.health = NewHealthHandler(database, logger, metricsManager)
        hm.scan = NewScanHandler(database, logger, metricsManager)
        hm.host = NewHostHandler(database, logger, metricsManager)
        hm.discovery = NewDiscoveryHandler(database, logger, metricsManager)
        hm.profile = NewProfileHandler(database, logger, metricsManager)
        hm.schedule = NewScheduleHandler(database, logger, metricsManager)
        hm.admin = NewAdminHandler(database, logger, metricsManager)
        hm.websocket = NewWebSocketHandler(database, logger, metricsManager)

        return hm
}</span>

// Health and status endpoints.
func (hm *HandlerManager) Health(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.health.Health(w, r)
}</span>

func (hm *HandlerManager) Status(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.health.Status(w, r)
}</span>

func (hm *HandlerManager) Version(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.health.Version(w, r)
}</span>

func (hm *HandlerManager) Metrics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.health.Metrics(w, r)
}</span>

// ListScans handles GET /api/v1/scans - list all scans.
func (hm *HandlerManager) ListScans(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.scan.ListScans(w, r)
}</span>

func (hm *HandlerManager) CreateScan(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.scan.CreateScan(w, r)
}</span>

func (hm *HandlerManager) GetScan(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.scan.GetScan(w, r)
}</span>

func (hm *HandlerManager) UpdateScan(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.scan.UpdateScan(w, r)
}</span>

func (hm *HandlerManager) DeleteScan(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.scan.DeleteScan(w, r)
}</span>

func (hm *HandlerManager) GetScanResults(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.scan.GetScanResults(w, r)
}</span>

func (hm *HandlerManager) StartScan(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.scan.StartScan(w, r)
}</span>

func (hm *HandlerManager) StopScan(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.scan.StopScan(w, r)
}</span>

// ListHosts handles GET /api/v1/hosts - list all hosts.
func (hm *HandlerManager) ListHosts(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.host.ListHosts(w, r)
}</span>

func (hm *HandlerManager) CreateHost(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.host.CreateHost(w, r)
}</span>

func (hm *HandlerManager) GetHost(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.host.GetHost(w, r)
}</span>

func (hm *HandlerManager) UpdateHost(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.host.UpdateHost(w, r)
}</span>

func (hm *HandlerManager) DeleteHost(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.host.DeleteHost(w, r)
}</span>

func (hm *HandlerManager) GetHostScans(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.host.GetHostScans(w, r)
}</span>

// ListDiscoveryJobs handles GET /api/v1/discovery - list all discovery jobs.
func (hm *HandlerManager) ListDiscoveryJobs(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.discovery.ListDiscoveryJobs(w, r)
}</span>

func (hm *HandlerManager) CreateDiscoveryJob(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.discovery.CreateDiscoveryJob(w, r)
}</span>

func (hm *HandlerManager) GetDiscoveryJob(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.discovery.GetDiscoveryJob(w, r)
}</span>

func (hm *HandlerManager) UpdateDiscoveryJob(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.discovery.UpdateDiscoveryJob(w, r)
}</span>

func (hm *HandlerManager) DeleteDiscoveryJob(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.discovery.DeleteDiscoveryJob(w, r)
}</span>

func (hm *HandlerManager) StartDiscovery(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.discovery.StartDiscovery(w, r)
}</span>

func (hm *HandlerManager) StopDiscovery(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.discovery.StopDiscovery(w, r)
}</span>

// ListProfiles handles GET /api/v1/profiles - list all profiles.
func (hm *HandlerManager) ListProfiles(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.profile.ListProfiles(w, r)
}</span>

func (hm *HandlerManager) CreateProfile(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.profile.CreateProfile(w, r)
}</span>

func (hm *HandlerManager) GetProfile(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.profile.GetProfile(w, r)
}</span>

func (hm *HandlerManager) UpdateProfile(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.profile.UpdateProfile(w, r)
}</span>

func (hm *HandlerManager) DeleteProfile(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.profile.DeleteProfile(w, r)
}</span>

// ListSchedules handles GET /api/v1/schedules - list all schedules.
func (hm *HandlerManager) ListSchedules(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.schedule.ListSchedules(w, r)
}</span>

func (hm *HandlerManager) CreateSchedule(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.schedule.CreateSchedule(w, r)
}</span>

func (hm *HandlerManager) GetSchedule(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.schedule.GetSchedule(w, r)
}</span>

func (hm *HandlerManager) UpdateSchedule(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.schedule.UpdateSchedule(w, r)
}</span>

func (hm *HandlerManager) DeleteSchedule(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.schedule.DeleteSchedule(w, r)
}</span>

func (hm *HandlerManager) EnableSchedule(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.schedule.EnableSchedule(w, r)
}</span>

func (hm *HandlerManager) DisableSchedule(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.schedule.DisableSchedule(w, r)
}</span>

// GetWorkerStatus retrieves the status of workers.
func (hm *HandlerManager) GetWorkerStatus(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.admin.GetWorkerStatus(w, r)
}</span>

// StopWorker stops a specific worker.
func (hm *HandlerManager) StopWorker(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.admin.StopWorker(w, r)
}</span>

// GetConfig retrieves the current configuration.
func (hm *HandlerManager) GetConfig(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.admin.GetConfig(w, r)
}</span>

// UpdateConfig updates the configuration.
func (hm *HandlerManager) UpdateConfig(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.admin.UpdateConfig(w, r)
}</span>

// GetLogs retrieves system logs.
func (hm *HandlerManager) GetLogs(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.admin.GetLogs(w, r)
}</span>

// ScanWebSocket handles WebSocket connections for scan updates.
func (hm *HandlerManager) ScanWebSocket(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.websocket.ScanWebSocket(w, r)
}</span>

// DiscoveryWebSocket handles WebSocket connections for discovery updates.
func (hm *HandlerManager) DiscoveryWebSocket(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hm.websocket.DiscoveryWebSocket(w, r)
}</span>

// GetDatabase returns the database instance.
func (hm *HandlerManager) GetDatabase() *db.DB <span class="cov0" title="0">{
        return hm.database
}</span>

// GetLogger returns the logger instance.
func (hm *HandlerManager) GetLogger() *slog.Logger <span class="cov0" title="0">{
        return hm.logger
}</span>

// GetMetrics returns the metrics manager.
func (hm *HandlerManager) GetMetrics() *metrics.Registry <span class="cov0" title="0">{
        return hm.metrics
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package handlers provides HTTP request handlers for the Scanorama API.
// This file implements scan profile management endpoints including CRUD operations
// and profile configurations for different scan types.
package handlers

import (
        "fmt"
        "log/slog"
        "net/http"
        "time"

        "github.com/anstrom/scanorama/internal/db"
        "github.com/anstrom/scanorama/internal/metrics"
)

// Profile validation constants.
const (
        maxProfileNameLength  = 255
        maxProfileDescLength  = 1000
        maxProfileHostTimeout = 30 * time.Minute
        maxProfileScanDelay   = 60 * time.Second
        maxProfileRetries     = 10
        maxProfileRatePPS     = 10000
        maxProfileTagLength   = 50
)

// ProfileHandler handles profile-related API endpoints.
type ProfileHandler struct {
        database *db.DB
        logger   *slog.Logger
        metrics  *metrics.Registry
}

// NewProfileHandler creates a new profile handler.
func NewProfileHandler(database *db.DB, logger *slog.Logger, metricsManager *metrics.Registry) *ProfileHandler <span class="cov0" title="0">{
        return &amp;ProfileHandler{
                database: database,
                logger:   logger.With("handler", "profile"),
                metrics:  metricsManager,
        }
}</span>

// ProfileRequest represents a profile creation/update request.
type ProfileRequest struct {
        Name        string `json:"name" validate:"required,min=1,max=255"`
        Description string `json:"description,omitempty"`
        // ScanType supports: connect, syn, ack, aggressive, comprehensive
        ScanType         string            `json:"scan_type" validate:"required"`
        Ports            string            `json:"ports,omitempty"`
        Options          map[string]string `json:"options,omitempty"`
        Timing           TimingProfile     `json:"timing,omitempty"`
        ServiceDetection bool              `json:"service_detection"`
        OSDetection      bool              `json:"os_detection"`
        ScriptScan       bool              `json:"script_scan"`
        UDPScan          bool              `json:"udp_scan"`
        MaxRetries       int               `json:"max_retries,omitempty"`
        HostTimeout      time.Duration     `json:"host_timeout,omitempty"`
        ScanDelay        time.Duration     `json:"scan_delay,omitempty"`
        MaxRatePPS       int               `json:"max_rate_pps,omitempty"`
        MaxHostGroupSize int               `json:"max_host_group_size,omitempty"`
        MinHostGroupSize int               `json:"min_host_group_size,omitempty"`
        Tags             []string          `json:"tags,omitempty"`
        Default          bool              `json:"default"`
}

// TimingProfile represents timing configuration for scans.
type TimingProfile struct {
        Template          string        `json:"template,omitempty"` // paranoid, sneaky, polite, normal, aggressive, insane
        MinRTTTimeout     time.Duration `json:"min_rtt_timeout,omitempty"`
        MaxRTTTimeout     time.Duration `json:"max_rtt_timeout,omitempty"`
        InitialRTTTimeout time.Duration `json:"initial_rtt_timeout,omitempty"`
        MaxRetries        int           `json:"max_retries,omitempty"`
        HostTimeout       time.Duration `json:"host_timeout,omitempty"`
        ScanDelay         time.Duration `json:"scan_delay,omitempty"`
        MaxScanDelay      time.Duration `json:"max_scan_delay,omitempty"`
}

// ProfileResponse represents a profile response.
type ProfileResponse struct {
        ID               int64             `json:"id"`
        Name             string            `json:"name"`
        Description      string            `json:"description,omitempty"`
        ScanType         string            `json:"scan_type"`
        Ports            string            `json:"ports,omitempty"`
        Options          map[string]string `json:"options,omitempty"`
        Timing           TimingProfile     `json:"timing,omitempty"`
        ServiceDetection bool              `json:"service_detection"`
        OSDetection      bool              `json:"os_detection"`
        ScriptScan       bool              `json:"script_scan"`
        UDPScan          bool              `json:"udp_scan"`
        MaxRetries       int               `json:"max_retries,omitempty"`
        HostTimeout      time.Duration     `json:"host_timeout,omitempty"`
        ScanDelay        time.Duration     `json:"scan_delay,omitempty"`
        MaxRatePPS       int               `json:"max_rate_pps,omitempty"`
        MaxHostGroupSize int               `json:"max_host_group_size,omitempty"`
        MinHostGroupSize int               `json:"min_host_group_size,omitempty"`
        Tags             []string          `json:"tags,omitempty"`
        Default          bool              `json:"default"`
        UsageCount       int               `json:"usage_count"`
        LastUsed         *time.Time        `json:"last_used,omitempty"`
        CreatedAt        time.Time         `json:"created_at"`
        UpdatedAt        time.Time         `json:"updated_at"`
        CreatedBy        string            `json:"created_by,omitempty"`
}

// ListProfiles handles GET /api/v1/profiles - list all profiles with pagination.
func (h *ProfileHandler) ListProfiles(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        listOp := &amp;ListOperation[*db.Profile, db.ProfileFilters]{
                EntityType: "profiles",
                MetricName: "api_profiles_listed_total",
                Logger:     h.logger,
                Metrics:    h.metrics,
                GetFilters: h.getProfileFilters,
                ListFromDB: h.database.ListProfiles,
                ToResponse: func(profile *db.Profile) interface{} </span><span class="cov0" title="0">{
                        return h.profileToResponse(profile)
                }</span>,
        }
        <span class="cov0" title="0">listOp.Execute(w, r)</span>
}

// CreateProfile handles POST /api/v1/profiles - create a new profile.
func (h *ProfileHandler) CreateProfile(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        CreateEntity[db.Profile, ProfileRequest](
                w, r,
                "profile",
                h.logger,
                h.metrics,
                func(r *http.Request) (interface{}, error) </span><span class="cov0" title="0">{
                        var req ProfileRequest
                        if err := parseJSON(r, &amp;req); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">if err := h.validateProfileRequest(&amp;req); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return h.requestToDBProfile(&amp;req), nil</span>
                },
                h.database.CreateProfile,
                func(profile *db.Profile) interface{} <span class="cov0" title="0">{
                        return h.profileToResponse(profile)
                }</span>,
                "api_profiles_created_total")
}

// GetProfile handles GET /api/v1/profiles/{id} - get a specific profile.
func (h *ProfileHandler) GetProfile(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        profileID, err := extractUUIDFromPath(r)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, r, http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov0" title="0">crudOp := &amp;CRUDOperation[db.Profile]{
                EntityType: "profile",
                Logger:     h.logger,
                Metrics:    h.metrics,
        }

        crudOp.ExecuteGet(w, r, profileID,
                h.database.GetProfile,
                func(profile *db.Profile) interface{} </span><span class="cov0" title="0">{
                        return h.profileToResponse(profile)
                }</span>,
                "api_profiles_retrieved_total")
}

// UpdateProfile handles PUT /api/v1/profiles/{id} - update a profile.
func (h *ProfileHandler) UpdateProfile(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        UpdateEntity[db.Profile, ProfileRequest](
                w, r,
                "profile",
                h.logger,
                h.metrics,
                func(r *http.Request) (interface{}, error) </span><span class="cov0" title="0">{
                        var req ProfileRequest
                        if err := parseJSON(r, &amp;req); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">if err := h.validateProfileRequest(&amp;req); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return h.requestToDBProfile(&amp;req), nil</span>
                },
                h.database.UpdateProfile,
                func(profile *db.Profile) interface{} <span class="cov0" title="0">{
                        return h.profileToResponse(profile)
                }</span>,
                "api_profiles_updated_total")
}

// DeleteProfile handles DELETE /api/v1/profiles/{id} - delete a profile.
func (h *ProfileHandler) DeleteProfile(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        profileID, err := extractUUIDFromPath(r)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, r, http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov0" title="0">crudOp := &amp;CRUDOperation[db.Profile]{
                EntityType: "profile",
                Logger:     h.logger,
                Metrics:    h.metrics,
        }

        crudOp.ExecuteDelete(w, r, profileID, h.database.DeleteProfile, "api_profiles_deleted_total")</span>
}

// Helper methods

// validateProfileRequest validates a profile request.
func (h *ProfileHandler) validateProfileRequest(req *ProfileRequest) error <span class="cov0" title="0">{
        if err := h.validateBasicProfileFields(req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := h.validateProfileScanType(req.ScanType); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := h.validateTimingTemplate(req.Timing.Template); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := h.validateProfileTimeouts(req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := h.validateProfileRateLimiting(req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := h.validateHostGroupSizes(req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return h.validateProfileTags(req.Tags)</span>
}

func (h *ProfileHandler) validateBasicProfileFields(req *ProfileRequest) error <span class="cov0" title="0">{
        if req.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("profile name is required")
        }</span>
        <span class="cov0" title="0">if len(req.Name) &gt; maxProfileNameLength </span><span class="cov0" title="0">{
                return fmt.Errorf("profile name too long (max %d characters)", maxProfileNameLength)
        }</span>
        <span class="cov0" title="0">if len(req.Description) &gt; maxProfileDescLength </span><span class="cov0" title="0">{
                return fmt.Errorf("description too long (max %d characters)", maxProfileDescLength)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (h *ProfileHandler) validateProfileScanType(scanType string) error <span class="cov0" title="0">{
        validScanTypes := map[string]bool{
                "connect":       true,
                "syn":           true,
                "ack":           true,
                "aggressive":    true,
                "comprehensive": true,
        }
        if !validScanTypes[scanType] </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid scan type: %s", scanType)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (h *ProfileHandler) validateTimingTemplate(template string) error <span class="cov0" title="0">{
        if template == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">validTimingTemplates := map[string]bool{
                "paranoid":   true,
                "sneaky":     true,
                "polite":     true,
                "normal":     true,
                "aggressive": true,
                "insane":     true,
        }
        if !validTimingTemplates[template] </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid timing template: %s", template)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (h *ProfileHandler) validateProfileTimeouts(req *ProfileRequest) error <span class="cov0" title="0">{
        if req.HostTimeout &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("host timeout cannot be negative")
        }</span>
        <span class="cov0" title="0">if req.HostTimeout &gt; maxProfileHostTimeout </span><span class="cov0" title="0">{
                return fmt.Errorf("host timeout too long (max %v)", maxProfileHostTimeout)
        }</span>
        <span class="cov0" title="0">if req.ScanDelay &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("scan delay cannot be negative")
        }</span>
        <span class="cov0" title="0">if req.ScanDelay &gt; maxProfileScanDelay </span><span class="cov0" title="0">{
                return fmt.Errorf("scan delay too long (max %v)", maxProfileScanDelay)
        }</span>
        <span class="cov0" title="0">if req.Timing.MinRTTTimeout &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("min RTT timeout cannot be negative")
        }</span>
        <span class="cov0" title="0">if req.Timing.MaxRTTTimeout &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("max RTT timeout cannot be negative")
        }</span>
        <span class="cov0" title="0">if req.Timing.MinRTTTimeout &gt; req.Timing.MaxRTTTimeout &amp;&amp; req.Timing.MaxRTTTimeout &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("min RTT timeout cannot be greater than max RTT timeout")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (h *ProfileHandler) validateProfileRateLimiting(req *ProfileRequest) error <span class="cov0" title="0">{
        if req.MaxRetries &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("max retries cannot be negative")
        }</span>
        <span class="cov0" title="0">if req.MaxRetries &gt; maxProfileRetries </span><span class="cov0" title="0">{
                return fmt.Errorf("max retries too high (max %d)", maxProfileRetries)
        }</span>
        <span class="cov0" title="0">if req.MaxRatePPS &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("max rate PPS cannot be negative")
        }</span>
        <span class="cov0" title="0">if req.MaxRatePPS &gt; maxProfileRatePPS </span><span class="cov0" title="0">{
                return fmt.Errorf("max rate PPS too high (max %d)", maxProfileRatePPS)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (h *ProfileHandler) validateHostGroupSizes(req *ProfileRequest) error <span class="cov0" title="0">{
        if req.MaxHostGroupSize &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("max host group size cannot be negative")
        }</span>
        <span class="cov0" title="0">if req.MinHostGroupSize &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("min host group size cannot be negative")
        }</span>
        <span class="cov0" title="0">if req.MinHostGroupSize &gt; req.MaxHostGroupSize &amp;&amp; req.MaxHostGroupSize &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("min host group size cannot be greater than max host group size")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (h *ProfileHandler) validateProfileTags(tags []string) error <span class="cov0" title="0">{
        for i, tag := range tags </span><span class="cov0" title="0">{
                if tag == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("tag %d is empty", i+1)
                }</span>
                <span class="cov0" title="0">if len(tag) &gt; maxProfileTagLength </span><span class="cov0" title="0">{
                        return fmt.Errorf("tag %d too long (max %d characters)", i+1, maxProfileTagLength)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// getProfileFilters extracts filter parameters from request.
func (h *ProfileHandler) getProfileFilters(r *http.Request) db.ProfileFilters <span class="cov0" title="0">{
        filters := db.ProfileFilters{}

        if scanType := r.URL.Query().Get("scan_type"); scanType != "" </span><span class="cov0" title="0">{
                filters.ScanType = scanType
        }</span>

        <span class="cov0" title="0">return filters</span>
}

// requestToDBProfile converts a profile request to database profile object.
func (h *ProfileHandler) requestToDBProfile(req *ProfileRequest) interface{} <span class="cov0" title="0">{
        // This should return the appropriate database profile type
        // The exact structure would depend on the database package implementation
        return map[string]interface{}{
                "name":                req.Name,
                "description":         req.Description,
                "scan_type":           req.ScanType,
                "ports":               req.Ports,
                "options":             req.Options,
                "timing":              req.Timing,
                "service_detection":   req.ServiceDetection,
                "os_detection":        req.OSDetection,
                "script_scan":         req.ScriptScan,
                "udp_scan":            req.UDPScan,
                "max_retries":         req.MaxRetries,
                "host_timeout":        req.HostTimeout,
                "scan_delay":          req.ScanDelay,
                "max_rate_pps":        req.MaxRatePPS,
                "max_host_group_size": req.MaxHostGroupSize,
                "min_host_group_size": req.MinHostGroupSize,
                "tags":                req.Tags,
                "default":             req.Default,
                "usage_count":         0,
                "created_at":          time.Now().UTC(),
                "updated_at":          time.Now().UTC(),
        }
}</span>

// profileToResponse converts a database profile to response format.
func (h *ProfileHandler) profileToResponse(_ interface{}) ProfileResponse <span class="cov0" title="0">{
        // This would convert from the actual database profile type
        // For now, return a placeholder structure
        return ProfileResponse{
                ID:               1,                // profile.ID
                Name:             "",               // profile.Name
                Description:      "",               // profile.Description
                ScanType:         "connect",        // profile.ScanType
                ServiceDetection: false,            // profile.ServiceDetection
                OSDetection:      false,            // profile.OSDetection
                ScriptScan:       false,            // profile.ScriptScan
                UDPScan:          false,            // profile.UDPScan
                Tags:             []string{},       // profile.Tags
                Default:          false,            // profile.Default
                UsageCount:       0,                // profile.UsageCount
                CreatedAt:        time.Now().UTC(), // profile.CreatedAt
                UpdatedAt:        time.Now().UTC(), // profile.UpdatedAt
        }
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package handlers provides HTTP request handlers for the Scanorama API.
// This file implements scan management endpoints including CRUD operations,
// scan execution control, and results retrieval.
package handlers

import (
        "context"
        "fmt"
        "log/slog"
        "net/http"
        "strconv"
        "time"

        "github.com/google/uuid"

        "github.com/anstrom/scanorama/internal/db"
        "github.com/anstrom/scanorama/internal/errors"
        "github.com/anstrom/scanorama/internal/metrics"
)

// Scan validation constants.
const (
        maxScanNameLength = 255
        maxTargetLength   = 255
)

// ScanHandler handles scan-related API endpoints.
type ScanHandler struct {
        database *db.DB
        logger   *slog.Logger
        metrics  *metrics.Registry
}

// NewScanHandler creates a new scan handler.
func NewScanHandler(database *db.DB, logger *slog.Logger, metricsManager *metrics.Registry) *ScanHandler <span class="cov0" title="0">{
        return &amp;ScanHandler{
                database: database,
                logger:   logger.With("handler", "scan"),
                metrics:  metricsManager,
        }
}</span>

// ScanRequest represents a scan creation/update request.
type ScanRequest struct {
        Name        string            `json:"name" validate:"required,min=1,max=255"`
        Description string            `json:"description,omitempty"`
        Targets     []string          `json:"targets" validate:"required,min=1"`
        ScanType    string            `json:"scan_type" validate:"required,oneof=connect syn ack aggressive comprehensive"`
        Ports       string            `json:"ports,omitempty"`
        ProfileID   *int64            `json:"profile_id,omitempty"`
        Options     map[string]string `json:"options,omitempty"`
        ScheduleID  *int64            `json:"schedule_id,omitempty"`
        Tags        []string          `json:"tags,omitempty"`
}

// ScanResponse represents a scan response.
type ScanResponse struct {
        ID          uuid.UUID         `json:"id"`
        Name        string            `json:"name"`
        Description string            `json:"description,omitempty"`
        Targets     []string          `json:"targets"`
        ScanType    string            `json:"scan_type"`
        Ports       string            `json:"ports,omitempty"`
        ProfileID   *int64            `json:"profile_id,omitempty"`
        Options     map[string]string `json:"options,omitempty"`
        ScheduleID  *int64            `json:"schedule_id,omitempty"`
        Tags        []string          `json:"tags,omitempty"`
        Status      string            `json:"status"`
        Progress    float64           `json:"progress"`
        StartTime   *time.Time        `json:"start_time,omitempty"`
        EndTime     *time.Time        `json:"end_time,omitempty"`
        Duration    *string           `json:"duration,omitempty"`
        CreatedAt   time.Time         `json:"created_at"`
        UpdatedAt   time.Time         `json:"updated_at"`
        CreatedBy   string            `json:"created_by,omitempty"`
}

// ScanResultsResponse represents scan results.
type ScanResultsResponse struct {
        ScanID      uuid.UUID       `json:"scan_id"`
        TotalHosts  int             `json:"total_hosts"`
        TotalPorts  int             `json:"total_ports"`
        OpenPorts   int             `json:"open_ports"`
        ClosedPorts int             `json:"closed_ports"`
        Results     []ScanResult    `json:"results"`
        Summary     *db.ScanSummary `json:"summary"`
        GeneratedAt time.Time       `json:"generated_at"`
}

// ScanResult represents an individual scan result.
type ScanResult struct {
        ID       uuid.UUID `json:"id"`
        HostIP   string    `json:"host_ip"`
        Hostname string    `json:"hostname,omitempty"`
        Port     int       `json:"port"`
        Protocol string    `json:"protocol"`
        State    string    `json:"state"`
        Service  string    `json:"service,omitempty"`
        Version  string    `json:"version,omitempty"`
        Banner   string    `json:"banner,omitempty"`
        ScanTime time.Time `json:"scan_time"`
}

// ListScans handles GET /api/v1/scans - list all scans with pagination.
// ListScans handles GET /api/v1/scans - list scans with filtering and pagination.
func (h *ScanHandler) ListScans(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        listOp := &amp;ListOperation[*db.Scan, db.ScanFilters]{
                EntityType: "scans",
                MetricName: "api_scans_listed_total",
                Logger:     h.logger,
                Metrics:    h.metrics,
                GetFilters: h.getScanFilters,
                ListFromDB: h.database.ListScans,
                ToResponse: func(scan *db.Scan) interface{} </span><span class="cov0" title="0">{
                        return h.scanToResponse(scan)
                }</span>,
        }
        <span class="cov0" title="0">listOp.Execute(w, r)</span>
}

// CreateScan handles POST /api/v1/scans - create a new scan.
func (h *ScanHandler) CreateScan(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        requestID := getRequestIDFromContext(r.Context())
        h.logger.Info("Creating scan", "request_id", requestID)

        // Parse request body
        var req ScanRequest
        if err := parseJSON(r, &amp;req); err != nil </span><span class="cov0" title="0">{
                writeError(w, r, http.StatusBadRequest, err)
                return
        }</span>

        // Validate request
        <span class="cov0" title="0">if err := h.validateScanRequest(&amp;req); err != nil </span><span class="cov0" title="0">{
                writeError(w, r, http.StatusBadRequest, err)
                return
        }</span>

        // Create scan in database
        <span class="cov0" title="0">scan, err := h.database.CreateScan(r.Context(), h.requestToDBScan(&amp;req))
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to create scan", "request_id", requestID, "error", err)
                writeError(w, r, http.StatusInternalServerError,
                        fmt.Errorf("failed to create scan: %w", err))
                return
        }</span>

        <span class="cov0" title="0">response := h.scanToResponse(scan)

        h.logger.Info("Scan created successfully",
                "request_id", requestID,
                "scan_id", response.ID,
                "scan_name", response.Name)

        writeJSON(w, r, http.StatusCreated, response)

        // Record metrics
        if h.metrics != nil </span><span class="cov0" title="0">{
                h.metrics.Counter("api_scans_created_total", map[string]string{
                        "scan_type": req.ScanType,
                })
        }</span>
}

// GetScan handles GET /api/v1/scans/{id} - get a specific scan.
func (h *ScanHandler) GetScan(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        scanID, err := extractUUIDFromPath(r)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, r, http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov0" title="0">crudOp := &amp;CRUDOperation[db.Scan]{
                EntityType: "scan",
                Logger:     h.logger,
                Metrics:    h.metrics,
        }

        crudOp.ExecuteGet(w, r, scanID, h.database.GetScan,
                func(scan *db.Scan) interface{} </span><span class="cov0" title="0">{
                        return h.scanToResponse(scan)
                }</span>, "api_scans_retrieved_total")
}

// UpdateScan handles PUT /api/v1/scans/{id} - update a scan.
func (h *ScanHandler) UpdateScan(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        UpdateEntity[db.Scan, ScanRequest](
                w, r,
                "scan",
                h.logger,
                h.metrics,
                func(r *http.Request) (interface{}, error) </span><span class="cov0" title="0">{
                        var req ScanRequest
                        if err := parseJSON(r, &amp;req); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return h.requestToDBScan(&amp;req), nil</span>
                },
                h.database.UpdateScan,
                func(scan *db.Scan) interface{} <span class="cov0" title="0">{
                        return h.scanToResponse(scan)
                }</span>,
                "api_scans_updated_total")
}

// DeleteScan handles DELETE /api/v1/scans/{id} - delete a scan.
func (h *ScanHandler) DeleteScan(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        scanID, err := extractUUIDFromPath(r)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, r, http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov0" title="0">crudOp := &amp;CRUDOperation[db.Scan]{
                EntityType: "scan",
                Logger:     h.logger,
                Metrics:    h.metrics,
        }

        crudOp.ExecuteDelete(w, r, scanID, h.database.DeleteScan, "api_scans_deleted_total")</span>
}

// GetScanResults handles GET /api/v1/scans/{id}/results - get scan results.
func (h *ScanHandler) GetScanResults(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        requestID := getRequestIDFromContext(r.Context())

        // Extract scan ID from URL
        scanID, err := extractUUIDFromPath(r)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, r, http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Getting scan results", "request_id", requestID, "scan_id", scanID)

        // Parse pagination parameters
        params, err := getPaginationParams(r)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, r, http.StatusBadRequest, err)
                return
        }</span>

        // Get scan results from database
        <span class="cov0" title="0">results, _, err := h.database.GetScanResults(r.Context(), scanID, params.Offset, params.PageSize)
        if err != nil </span><span class="cov0" title="0">{
                if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        writeError(w, r, http.StatusNotFound, fmt.Errorf("scan not found"))
                        return
                }</span>
                <span class="cov0" title="0">h.logger.Error("Failed to get scan results", "request_id", requestID, "scan_id", scanID, "error", err)
                writeError(w, r, http.StatusInternalServerError,
                        fmt.Errorf("failed to retrieve scan results: %w", err))
                return</span>
        }

        // Get scan summary
        <span class="cov0" title="0">summary, err := h.database.GetScanSummary(r.Context(), scanID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("Failed to get scan summary", "request_id", requestID, "scan_id", scanID, "error", err)
                summary = &amp;db.ScanSummary{
                        ScanID:      scanID,
                        TotalHosts:  0,
                        TotalPorts:  0,
                        OpenPorts:   0,
                        ClosedPorts: 0,
                        Duration:    0,
                }
        }</span>

        // Convert to response format
        <span class="cov0" title="0">scanResults := make([]ScanResult, len(results))
        for i, result := range results </span><span class="cov0" title="0">{
                scanResults[i] = h.resultToResponse(result)
        }</span>

        <span class="cov0" title="0">response := ScanResultsResponse{
                ScanID:      scanID,
                TotalHosts:  summary.TotalHosts,
                TotalPorts:  len(results),
                OpenPorts:   summary.OpenPorts,
                ClosedPorts: summary.ClosedPorts,
                Results:     scanResults,
                Summary:     summary,
                GeneratedAt: time.Now().UTC(),
        }

        writeJSON(w, r, http.StatusOK, response)

        // Record metrics
        if h.metrics != nil </span><span class="cov0" title="0">{
                h.metrics.Counter("api_scan_results_retrieved_total", map[string]string{
                        "scan_id": scanID.String(),
                })
        }</span>
}

// StartScan handles POST /api/v1/scans/{id}/start - start scan execution.
func (h *ScanHandler) StartScan(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        scanID, err := extractUUIDFromPath(r)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, r, http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov0" title="0">jobOp := &amp;JobControlOperation{
                EntityType: "scan",
                Logger:     h.logger,
                Metrics:    h.metrics,
        }

        jobOp.ExecuteStart(w, r, scanID, h.database.StartScan,
                func(ctx context.Context, id uuid.UUID) (interface{}, error) </span><span class="cov0" title="0">{
                        return h.database.GetScan(ctx, id)
                }</span>,
                func(item interface{}) interface{} <span class="cov0" title="0">{
                        if scan, ok := item.(*db.Scan); ok </span><span class="cov0" title="0">{
                                return h.scanToResponse(scan)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }, "api_scans_started_total")
}

// StopScan handles POST /api/v1/scans/{id}/stop - stop scan execution.
func (h *ScanHandler) StopScan(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        scanID, err := extractUUIDFromPath(r)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, r, http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov0" title="0">jobOp := &amp;JobControlOperation{
                EntityType: "scan",
                Logger:     h.logger,
                Metrics:    h.metrics,
        }

        jobOp.ExecuteStop(w, r, scanID, h.database.StopScan, "api_scans_stopped_total")</span>
}

// Helper methods

// validateScanRequest validates a scan request.
func (h *ScanHandler) validateScanRequest(req *ScanRequest) error <span class="cov0" title="0">{
        if req.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("scan name is required")
        }</span>

        <span class="cov0" title="0">if len(req.Name) &gt; maxScanNameLength </span><span class="cov0" title="0">{
                return fmt.Errorf("scan name too long (max %d characters)", maxScanNameLength)
        }</span>

        <span class="cov0" title="0">if len(req.Targets) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("at least one target is required")
        }</span>

        // Validate scan type
        <span class="cov0" title="0">validScanTypes := map[string]bool{
                "connect":       true,
                "syn":           true,
                "ack":           true,
                "aggressive":    true,
                "comprehensive": true,
        }

        if !validScanTypes[req.ScanType] </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid scan type: %s", req.ScanType)
        }</span>

        // Validate targets format (basic validation)
        <span class="cov0" title="0">for i, target := range req.Targets </span><span class="cov0" title="0">{
                if target == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("target %d is empty", i+1)
                }</span>
                <span class="cov0" title="0">if len(target) &gt; maxTargetLength </span><span class="cov0" title="0">{
                        return fmt.Errorf("target %d too long (max %d characters)", i+1, maxTargetLength)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// getScanFilters extracts filter parameters from request.
func (h *ScanHandler) getScanFilters(r *http.Request) db.ScanFilters <span class="cov0" title="0">{
        filters := db.ScanFilters{}

        if status := r.URL.Query().Get("status"); status != "" </span><span class="cov0" title="0">{
                filters.Status = status
        }</span>

        <span class="cov0" title="0">if scanType := r.URL.Query().Get("scan_type"); scanType != "" </span><span class="cov0" title="0">{
                filters.ScanType = scanType
        }</span>

        <span class="cov0" title="0">if tag := r.URL.Query().Get("tag"); tag != "" </span><span class="cov0" title="0">{
                filters.Tags = []string{tag}
        }</span>

        <span class="cov0" title="0">if profileID := r.URL.Query().Get("profile_id"); profileID != "" </span><span class="cov0" title="0">{
                if id, err := strconv.ParseInt(profileID, 10, 64); err == nil </span><span class="cov0" title="0">{
                        filters.ProfileID = &amp;id
                }</span>
        }

        <span class="cov0" title="0">return filters</span>
}

// requestToDBScan converts a scan request to database scan object.
func (h *ScanHandler) requestToDBScan(req *ScanRequest) interface{} <span class="cov0" title="0">{
        // This should return the appropriate database scan type
        // The exact structure would depend on the database package implementation
        return map[string]interface{}{
                "name":        req.Name,
                "description": req.Description,
                "targets":     req.Targets,
                "scan_type":   req.ScanType,
                "ports":       req.Ports,
                "profile_id":  req.ProfileID,
                "options":     req.Options,
                "schedule_id": req.ScheduleID,
                "tags":        req.Tags,
                "status":      "pending",
                "created_at":  time.Now().UTC(),
        }
}</span>

// scanToResponse converts a database scan to response format.
func (h *ScanHandler) scanToResponse(scan *db.Scan) ScanResponse <span class="cov0" title="0">{
        // This would convert from the actual database scan type
        // For now, return a placeholder structure
        return ScanResponse{
                ID:          scan.ID,
                Name:        scan.Name,
                Description: scan.Description,
                Targets:     []string{}, // scan.Targets
                ScanType:    scan.ScanType,
                Status:      scan.Status,
                Progress:    0.0,
                CreatedAt:   scan.CreatedAt,
                UpdatedAt:   scan.UpdatedAt,
        }
}</span>

// resultToResponse converts a database scan result to response format.
func (h *ScanHandler) resultToResponse(result *db.ScanResult) ScanResult <span class="cov0" title="0">{
        return ScanResult{
                ID:       result.ID,
                HostIP:   "", // Would need to lookup host IP from HostID
                Hostname: "", // Would need to lookup hostname from HostID
                Port:     result.Port,
                Protocol: result.Protocol,
                State:    result.State,
                Service:  result.Service,
                Version:  "",               // Not available in current db.ScanResult
                Banner:   "",               // Not available in current db.ScanResult
                ScanTime: time.Now().UTC(), // Would use actual scan time from database
        }
}</span>

// Helper functions for response utilities
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package handlers provides HTTP request handlers for the Scanorama API.
// This file implements schedule management endpoints including CRUD operations
// and schedule activation/deactivation.
package handlers

import (
        "fmt"
        "log/slog"
        "net/http"
        "strconv"
        "strings"
        "time"

        "github.com/anstrom/scanorama/internal/db"
        "github.com/anstrom/scanorama/internal/errors"
        "github.com/anstrom/scanorama/internal/metrics"
)

// Schedule validation constants.
const (
        maxScheduleNameLength = 255
        maxScheduleDescLength = 1000
        maxScheduleTagLength  = 50
        maxScheduleRetries    = 10
)

// ScheduleHandler handles schedule-related API endpoints.
type ScheduleHandler struct {
        database *db.DB
        logger   *slog.Logger
        metrics  *metrics.Registry
}

// NewScheduleHandler creates a new schedule handler.
func NewScheduleHandler(database *db.DB, logger *slog.Logger, metricsManager *metrics.Registry) *ScheduleHandler <span class="cov0" title="0">{
        return &amp;ScheduleHandler{
                database: database,
                logger:   logger.With("handler", "schedule"),
                metrics:  metricsManager,
        }
}</span>

// ScheduleRequest represents a schedule creation/update request.
type ScheduleRequest struct {
        Name         string            `json:"name" validate:"required,min=1,max=255"`
        Description  string            `json:"description,omitempty"`
        CronExpr     string            `json:"cron_expr" validate:"required"`
        Type         string            `json:"type" validate:"required,oneof=scan discovery"`
        TargetID     int64             `json:"target_id" validate:"required"`
        Enabled      bool              `json:"enabled"`
        MaxRunTime   time.Duration     `json:"max_run_time,omitempty"`
        RetryOnError bool              `json:"retry_on_error"`
        MaxRetries   int               `json:"max_retries,omitempty"`
        RetryDelay   time.Duration     `json:"retry_delay,omitempty"`
        Options      map[string]string `json:"options,omitempty"`
        Tags         []string          `json:"tags,omitempty"`
        NotifyOnFail bool              `json:"notify_on_fail"`
        NotifyEmails []string          `json:"notify_emails,omitempty"`
}

// ScheduleResponse represents a schedule response.
type ScheduleResponse struct {
        ID           int64             `json:"id"`
        Name         string            `json:"name"`
        Description  string            `json:"description,omitempty"`
        CronExpr     string            `json:"cron_expr"`
        Type         string            `json:"type"`
        TargetID     int64             `json:"target_id"`
        TargetName   string            `json:"target_name,omitempty"`
        Enabled      bool              `json:"enabled"`
        MaxRunTime   time.Duration     `json:"max_run_time,omitempty"`
        RetryOnError bool              `json:"retry_on_error"`
        MaxRetries   int               `json:"max_retries,omitempty"`
        RetryDelay   time.Duration     `json:"retry_delay,omitempty"`
        Options      map[string]string `json:"options,omitempty"`
        Tags         []string          `json:"tags,omitempty"`
        NotifyOnFail bool              `json:"notify_on_fail"`
        NotifyEmails []string          `json:"notify_emails,omitempty"`
        Status       string            `json:"status"`
        LastRun      *time.Time        `json:"last_run,omitempty"`
        NextRun      *time.Time        `json:"next_run,omitempty"`
        RunCount     int               `json:"run_count"`
        SuccessCount int               `json:"success_count"`
        ErrorCount   int               `json:"error_count"`
        LastError    string            `json:"last_error,omitempty"`
        LastDuration *time.Duration    `json:"last_duration,omitempty"`
        AvgDuration  *time.Duration    `json:"avg_duration,omitempty"`
        CreatedAt    time.Time         `json:"created_at"`
        UpdatedAt    time.Time         `json:"updated_at"`
        CreatedBy    string            `json:"created_by,omitempty"`
}

// ListSchedules handles GET /api/v1/schedules - list all schedules with pagination.
func (h *ScheduleHandler) ListSchedules(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        listOp := &amp;ListOperation[*db.Schedule, db.ScheduleFilters]{
                EntityType: "schedules",
                MetricName: "api_schedules_listed_total",
                Logger:     h.logger,
                Metrics:    h.metrics,
                GetFilters: h.getScheduleFilters,
                ListFromDB: h.database.ListSchedules,
                ToResponse: func(schedule *db.Schedule) interface{} </span><span class="cov0" title="0">{
                        return h.scheduleToResponse(schedule)
                }</span>,
        }
        <span class="cov0" title="0">listOp.Execute(w, r)</span>
}

// CreateSchedule handles POST /api/v1/schedules - create a new schedule.
func (h *ScheduleHandler) CreateSchedule(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        CreateEntity[db.Schedule, ScheduleRequest](
                w, r,
                "schedule",
                h.logger,
                h.metrics,
                func(r *http.Request) (interface{}, error) </span><span class="cov0" title="0">{
                        var req ScheduleRequest
                        if err := parseJSON(r, &amp;req); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">if err := h.validateScheduleRequest(&amp;req); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return h.requestToDBSchedule(&amp;req), nil</span>
                },
                h.database.CreateSchedule,
                func(schedule *db.Schedule) interface{} <span class="cov0" title="0">{
                        return h.scheduleToResponse(schedule)
                }</span>,
                "api_schedules_created_total")
}

// GetSchedule handles GET /api/v1/schedules/{id} - get a specific schedule.
func (h *ScheduleHandler) GetSchedule(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        scheduleID, err := extractUUIDFromPath(r)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, r, http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov0" title="0">crudOp := &amp;CRUDOperation[db.Schedule]{
                EntityType: "schedule",
                Logger:     h.logger,
                Metrics:    h.metrics,
        }

        crudOp.ExecuteGet(w, r, scheduleID,
                h.database.GetSchedule,
                func(schedule *db.Schedule) interface{} </span><span class="cov0" title="0">{
                        return h.scheduleToResponse(schedule)
                }</span>,
                "api_schedules_retrieved_total")
}

// UpdateSchedule handles PUT /api/v1/schedules/{id} - update a schedule.
func (h *ScheduleHandler) UpdateSchedule(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        UpdateEntity[db.Schedule, ScheduleRequest](
                w, r,
                "schedule",
                h.logger,
                h.metrics,
                func(r *http.Request) (interface{}, error) </span><span class="cov0" title="0">{
                        var req ScheduleRequest
                        if err := parseJSON(r, &amp;req); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">if err := h.validateScheduleRequest(&amp;req); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return h.requestToDBSchedule(&amp;req), nil</span>
                },
                h.database.UpdateSchedule,
                func(schedule *db.Schedule) interface{} <span class="cov0" title="0">{
                        return h.scheduleToResponse(schedule)
                }</span>,
                "api_schedules_updated_total")
}

// DeleteSchedule handles DELETE /api/v1/schedules/{id} - delete a schedule.
func (h *ScheduleHandler) DeleteSchedule(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        scheduleID, err := extractUUIDFromPath(r)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, r, http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov0" title="0">crudOp := &amp;CRUDOperation[db.Schedule]{
                EntityType: "schedule",
                Logger:     h.logger,
                Metrics:    h.metrics,
        }

        crudOp.ExecuteDelete(w, r, scheduleID, h.database.DeleteSchedule, "api_schedules_deleted_total")</span>
}

// EnableSchedule handles POST /api/v1/schedules/{id}/enable - enable a schedule.
func (h *ScheduleHandler) EnableSchedule(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        requestID := getRequestIDFromContext(r.Context())

        // Extract schedule ID from URL
        scheduleID, err := extractUUIDFromPath(r)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, r, http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Enabling schedule", "request_id", requestID, "schedule_id", scheduleID)

        // Enable schedule in database
        err = h.database.EnableSchedule(r.Context(), scheduleID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        writeError(w, r, http.StatusNotFound,
                                fmt.Errorf("schedule not found"))
                        return
                }</span>
                <span class="cov0" title="0">h.logger.Error("Failed to activate schedule", "request_id", requestID, "schedule_id", scheduleID, "error", err)
                writeError(w, r, http.StatusInternalServerError,
                        fmt.Errorf("failed to activate schedule: %w", err))
                return</span>
        }

        // Get updated schedule
        <span class="cov0" title="0">schedule, err := h.database.GetSchedule(r.Context(), scheduleID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get schedule after enable",
                        "request_id", requestID, "schedule_id", scheduleID, "error", err)
                // Still return success since the schedule was enabled
        }</span>

        <span class="cov0" title="0">response := map[string]interface{}{
                "schedule_id": scheduleID,
                "status":      "enabled",
                "message":     "Schedule has been enabled",
                "timestamp":   time.Now().UTC(),
                "request_id":  requestID,
        }

        if schedule != nil </span><span class="cov0" title="0">{
                response["schedule"] = h.scheduleToResponse(schedule)
        }</span>

        <span class="cov0" title="0">h.logger.Info("Schedule enabled successfully",
                "request_id", requestID,
                "schedule_id", scheduleID)

        writeJSON(w, r, http.StatusOK, response)

        // Record metrics
        if h.metrics != nil </span><span class="cov0" title="0">{
                h.metrics.Counter("api_schedules_enabled_total", nil)
        }</span>
}

// DisableSchedule handles POST /api/v1/schedules/{id}/disable - disable a schedule.
func (h *ScheduleHandler) DisableSchedule(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        requestID := getRequestIDFromContext(r.Context())

        // Extract schedule ID from URL
        scheduleID, err := extractUUIDFromPath(r)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, r, http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Disabling schedule", "request_id", requestID, "schedule_id", scheduleID)

        // Disable schedule in database
        err = h.database.DisableSchedule(r.Context(), scheduleID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        writeError(w, r, http.StatusNotFound,
                                fmt.Errorf("schedule not found"))
                        return
                }</span>
                <span class="cov0" title="0">h.logger.Error("Failed to deactivate schedule",
                        "request_id", requestID, "schedule_id", scheduleID, "error", err)
                writeError(w, r, http.StatusInternalServerError,
                        fmt.Errorf("failed to deactivate schedule: %w", err))
                return</span>
        }

        <span class="cov0" title="0">response := map[string]interface{}{
                "schedule_id": scheduleID,
                "status":      "disabled",
                "message":     "Schedule has been disabled",
                "timestamp":   time.Now().UTC(),
                "request_id":  requestID,
        }

        h.logger.Info("Schedule disabled successfully",
                "request_id", requestID,
                "schedule_id", scheduleID)

        writeJSON(w, r, http.StatusOK, response)

        // Record metrics
        if h.metrics != nil </span><span class="cov0" title="0">{
                h.metrics.Counter("api_schedules_disabled_total", nil)
        }</span>
}

// Helper methods

// validateScheduleRequest validates a schedule request.
func (h *ScheduleHandler) validateScheduleRequest(req *ScheduleRequest) error <span class="cov0" title="0">{
        if err := h.validateBasicScheduleFields(req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := h.validateScheduleCron(req.CronExpr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := h.validateScheduleType(req.Type); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := h.validateScheduleOptions(req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return h.validateScheduleTags(req.Tags)</span>
}

func (h *ScheduleHandler) validateBasicScheduleFields(req *ScheduleRequest) error <span class="cov0" title="0">{
        if req.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("schedule name is required")
        }</span>
        <span class="cov0" title="0">if len(req.Name) &gt; maxScheduleNameLength </span><span class="cov0" title="0">{
                return fmt.Errorf("schedule name too long (max %d characters)", maxScheduleNameLength)
        }</span>
        <span class="cov0" title="0">if len(req.Description) &gt; maxScheduleDescLength </span><span class="cov0" title="0">{
                return fmt.Errorf("description too long (max %d characters)", maxScheduleDescLength)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (h *ScheduleHandler) validateScheduleCron(cronExpr string) error <span class="cov0" title="0">{
        if cronExpr == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("cron expression is required")
        }</span>
        <span class="cov0" title="0">if err := h.validateCronExpression(cronExpr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid cron expression: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (h *ScheduleHandler) validateScheduleType(scheduleType string) error <span class="cov0" title="0">{
        validTypes := map[string]bool{
                "scan":      true,
                "discovery": true,
        }
        if !validTypes[scheduleType] </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid schedule type: %s", scheduleType)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (h *ScheduleHandler) validateScheduleOptions(req *ScheduleRequest) error <span class="cov0" title="0">{
        if req.TargetID &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("target ID must be positive")
        }</span>

        // Validate timeouts
        <span class="cov0" title="0">if req.MaxRunTime &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("max run time cannot be negative")
        }</span>
        <span class="cov0" title="0">if req.MaxRunTime &gt; 24*time.Hour </span><span class="cov0" title="0">{
                return fmt.Errorf("max run time too long (max 24 hours)")
        }</span>

        // Validate retries
        <span class="cov0" title="0">if req.MaxRetries &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("max retries cannot be negative")
        }</span>
        <span class="cov0" title="0">if req.MaxRetries &gt; maxScheduleRetries </span><span class="cov0" title="0">{
                return fmt.Errorf("max retries too high (max %d)", maxScheduleRetries)
        }</span>

        <span class="cov0" title="0">if req.RetryDelay &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("retry delay cannot be negative")
        }</span>
        <span class="cov0" title="0">if req.RetryDelay &gt; time.Hour </span><span class="cov0" title="0">{
                return fmt.Errorf("retry delay too long (max 1 hour)")
        }</span>

        // Validate notification emails
        <span class="cov0" title="0">for i, email := range req.NotifyEmails </span><span class="cov0" title="0">{
                if email == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("notification email %d is empty", i+1)
                }</span>
                <span class="cov0" title="0">if len(email) &gt; maxScheduleNameLength </span><span class="cov0" title="0">{
                        return fmt.Errorf("notification email %d too long (max %d characters)", i+1, maxScheduleNameLength)
                }</span>
                // Basic email format validation
                <span class="cov0" title="0">if !strings.Contains(email, "@") || !strings.Contains(email, ".") </span><span class="cov0" title="0">{
                        return fmt.Errorf("notification email %d has invalid format: %s", i+1, email)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (h *ScheduleHandler) validateScheduleTags(tags []string) error <span class="cov0" title="0">{
        for i, tag := range tags </span><span class="cov0" title="0">{
                if tag == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("tag %d is empty", i+1)
                }</span>
                <span class="cov0" title="0">if len(tag) &gt; maxScheduleTagLength </span><span class="cov0" title="0">{
                        return fmt.Errorf("tag %d too long (max %d characters)", i+1, maxScheduleTagLength)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// validateCronExpression performs basic cron expression validation.
func (h *ScheduleHandler) validateCronExpression(cronExpr string) error <span class="cov0" title="0">{
        // Basic validation - should be 5 or 6 fields separated by spaces
        fields := strings.Fields(cronExpr)
        if len(fields) != 5 &amp;&amp; len(fields) != 6 </span><span class="cov0" title="0">{
                return fmt.Errorf("cron expression must have 5 or 6 fields, got %d", len(fields))
        }</span>

        // TODO: Add more sophisticated cron validation using a cron library
        // For now, just check that each field is not empty
        <span class="cov0" title="0">for i, field := range fields </span><span class="cov0" title="0">{
                if field == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("cron field %d is empty", i+1)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// getScheduleFilters extracts filter parameters from request.
func (h *ScheduleHandler) getScheduleFilters(r *http.Request) db.ScheduleFilters <span class="cov0" title="0">{
        filters := db.ScheduleFilters{}

        if scheduleType := r.URL.Query().Get("type"); scheduleType != "" </span><span class="cov0" title="0">{
                filters.JobType = scheduleType
        }</span>

        <span class="cov0" title="0">if enabled := r.URL.Query().Get("enabled"); enabled != "" </span><span class="cov0" title="0">{
                if enabledVal, err := strconv.ParseBool(enabled); err == nil </span><span class="cov0" title="0">{
                        filters.Enabled = enabledVal
                }</span>
        }

        <span class="cov0" title="0">return filters</span>
}

// requestToDBSchedule converts a schedule request to database schedule object.
func (h *ScheduleHandler) requestToDBSchedule(req *ScheduleRequest) interface{} <span class="cov0" title="0">{
        // This should return the appropriate database schedule type
        // The exact structure would depend on the database package implementation
        return map[string]interface{}{
                "name":           req.Name,
                "description":    req.Description,
                "cron_expr":      req.CronExpr,
                "type":           req.Type,
                "target_id":      req.TargetID,
                "enabled":        req.Enabled,
                "max_run_time":   req.MaxRunTime,
                "retry_on_error": req.RetryOnError,
                "max_retries":    req.MaxRetries,
                "retry_delay":    req.RetryDelay,
                "options":        req.Options,
                "tags":           req.Tags,
                "notify_on_fail": req.NotifyOnFail,
                "notify_emails":  req.NotifyEmails,
                "status":         "pending",
                "run_count":      0,
                "success_count":  0,
                "error_count":    0,
                "created_at":     time.Now().UTC(),
                "updated_at":     time.Now().UTC(),
        }
}</span>

// scheduleToResponse converts a database schedule to response format.
func (h *ScheduleHandler) scheduleToResponse(_ interface{}) ScheduleResponse <span class="cov0" title="0">{
        // This would convert from the actual database schedule type
        // For now, return a placeholder structure
        return ScheduleResponse{
                ID:           1,                   // schedule.ID
                Name:         "",                  // schedule.Name
                Description:  "",                  // schedule.Description
                CronExpr:     "0 */6 * * *",       // schedule.CronExpr
                Type:         "scan",              // schedule.Type
                TargetID:     1,                   // schedule.TargetID
                Enabled:      true,                // schedule.Enabled
                RetryOnError: false,               // schedule.RetryOnError
                MaxRetries:   3,                   // schedule.MaxRetries
                Options:      map[string]string{}, // schedule.Options
                Tags:         []string{},          // schedule.Tags
                NotifyOnFail: false,               // schedule.NotifyOnFail
                NotifyEmails: []string{},          // schedule.NotifyEmails
                Status:       "active",            // schedule.Status
                RunCount:     0,                   // schedule.RunCount
                SuccessCount: 0,                   // schedule.SuccessCount
                ErrorCount:   0,                   // schedule.ErrorCount
                CreatedAt:    time.Now().UTC(),    // schedule.CreatedAt
                UpdatedAt:    time.Now().UTC(),    // schedule.UpdatedAt
        }
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package handlers provides HTTP request handlers for the Scanorama API.
// This file implements WebSocket endpoints for real-time updates on scan
// and discovery job progress, status changes, and results.
package handlers

import (
        "encoding/json"
        "fmt"
        "log/slog"
        "net/http"
        "sync"
        "time"

        "github.com/gorilla/websocket"

        "github.com/anstrom/scanorama/internal/db"
        "github.com/anstrom/scanorama/internal/metrics"
)

const (
        // WebSocket configuration constants.
        writeWait       = 10 * time.Second                                   // Time allowed to write a message to the peer
        pongWait        = 60 * time.Second                                   // Time to read next pong message from peer
        pingPeriodRatio = 0.9                                                // Ratio of pongWait for pingPeriod
        pingPeriod      = time.Duration(float64(pongWait) * pingPeriodRatio) // Send pings to peer (must be &lt; pongWait)
        maxMessageSize  = 512                                                // Maximum message size allowed from peer
        bufferSize      = 256                                                // Size of the broadcast channel buffer
)

// WebSocketHandler handles WebSocket connections for real-time updates.
type WebSocketHandler struct {
        database *db.DB
        logger   *slog.Logger
        metrics  *metrics.Registry
        upgrader websocket.Upgrader

        // Connection management
        scanClients        map[*websocket.Conn]bool
        discoveryClients   map[*websocket.Conn]bool
        scanBroadcast      chan []byte
        discoveryBroadcast chan []byte
        register           chan *clientRegistration
        unregister         chan *websocket.Conn
        mutex              sync.RWMutex
}

// clientRegistration represents a new client registration.
type clientRegistration struct {
        conn     *websocket.Conn
        connType string // "scan" or "discovery"
}

// WebSocketMessage represents a WebSocket message structure.
type WebSocketMessage struct {
        Type      string      `json:"type"`
        Timestamp time.Time   `json:"timestamp"`
        Data      interface{} `json:"data"`
        RequestID string      `json:"request_id,omitempty"`
}

// ScanUpdateMessage represents a scan status update.
type ScanUpdateMessage struct {
        ScanID       int64      `json:"scan_id"`
        Status       string     `json:"status"`
        Progress     float64    `json:"progress"`
        Message      string     `json:"message,omitempty"`
        Error        string     `json:"error,omitempty"`
        StartTime    *time.Time `json:"start_time,omitempty"`
        EndTime      *time.Time `json:"end_time,omitempty"`
        ResultsCount int        `json:"results_count,omitempty"`
}

// DiscoveryUpdateMessage represents a discovery job status update.
type DiscoveryUpdateMessage struct {
        JobID      int64   `json:"job_id"`
        Status     string  `json:"status"`
        Progress   float64 `json:"progress"`
        Message    string  `json:"message,omitempty"`
        Error      string  `json:"error,omitempty"`
        HostsFound int     `json:"hosts_found,omitempty"`
        NewHosts   int     `json:"new_hosts,omitempty"`
}

// NewWebSocketHandler creates a new WebSocket handler.
func NewWebSocketHandler(database *db.DB, logger *slog.Logger, metricsManager *metrics.Registry) *WebSocketHandler <span class="cov0" title="0">{
        handler := &amp;WebSocketHandler{
                database: database,
                logger:   logger.With("handler", "websocket"),
                metrics:  metricsManager,
                upgrader: websocket.Upgrader{
                        ReadBufferSize:  1024,
                        WriteBufferSize: 1024,
                        CheckOrigin: func(r *http.Request) bool </span><span class="cov0" title="0">{
                                // TODO: Implement proper origin checking based on configuration
                                return true
                        }</span>,
                },
                scanClients:        make(map[*websocket.Conn]bool),
                discoveryClients:   make(map[*websocket.Conn]bool),
                scanBroadcast:      make(chan []byte, bufferSize),
                discoveryBroadcast: make(chan []byte, bufferSize),
                register:           make(chan *clientRegistration),
                unregister:         make(chan *websocket.Conn),
        }

        // Start the hub goroutine
        <span class="cov0" title="0">go handler.run()

        return handler</span>
}

// ScanWebSocket handles WebSocket connections for scan updates.
func (h *WebSocketHandler) ScanWebSocket(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        requestID := getRequestIDFromContext(r.Context())
        h.logger.Info("New scan WebSocket connection", "request_id", requestID, "remote_addr", r.RemoteAddr)

        conn, err := h.upgrader.Upgrade(w, r, nil)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to upgrade WebSocket connection", "request_id", requestID, "error", err)
                return
        }</span>

        // Register the new client
        <span class="cov0" title="0">h.register &lt;- &amp;clientRegistration{
                conn:     conn,
                connType: "scan",
        }

        // Set up the connection
        h.setupConnection(conn, "scan", requestID)</span>
}

// DiscoveryWebSocket handles WebSocket connections for discovery updates.
func (h *WebSocketHandler) DiscoveryWebSocket(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        requestID := getRequestIDFromContext(r.Context())
        h.logger.Info("New discovery WebSocket connection", "request_id", requestID, "remote_addr", r.RemoteAddr)

        conn, err := h.upgrader.Upgrade(w, r, nil)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to upgrade WebSocket connection", "request_id", requestID, "error", err)
                return
        }</span>

        // Register the new client
        <span class="cov0" title="0">h.register &lt;- &amp;clientRegistration{
                conn:     conn,
                connType: "discovery",
        }

        // Set up the connection
        h.setupConnection(conn, "discovery", requestID)</span>
}

// setupConnection configures a WebSocket connection and starts read/write pumps.
func (h *WebSocketHandler) setupConnection(conn *websocket.Conn, connType, requestID string) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                h.unregister &lt;- conn
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Error closing WebSocket connection", "request_id", requestID, "error", err)
                }</span>
        }()

        // Configure connection settings
        <span class="cov0" title="0">conn.SetReadLimit(maxMessageSize)
        if err := conn.SetReadDeadline(time.Now().Add(pongWait)); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to set read deadline", "request_id", requestID, "error", err)
                return
        }</span>
        <span class="cov0" title="0">conn.SetPongHandler(func(string) error </span><span class="cov0" title="0">{
                return conn.SetReadDeadline(time.Now().Add(pongWait))
        }</span>)

        // Start write pump in goroutine
        <span class="cov0" title="0">go h.writePump(conn, connType, requestID)

        // Start read pump (blocks until connection closes)
        h.readPump(conn, requestID)</span>
}

// run manages client connections and broadcasts.
func (h *WebSocketHandler) run() <span class="cov0" title="0">{
        ticker := time.NewTicker(pingPeriod)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case registration := &lt;-h.register:<span class="cov0" title="0">
                        h.mutex.Lock()
                        switch registration.connType </span>{
                        case "scan":<span class="cov0" title="0">
                                h.scanClients[registration.conn] = true</span>
                        case "discovery":<span class="cov0" title="0">
                                h.discoveryClients[registration.conn] = true</span>
                        }
                        <span class="cov0" title="0">h.mutex.Unlock()

                        h.logger.Debug("Client registered", "type", registration.connType, "total_clients", h.getTotalClients())</span>

                case conn := &lt;-h.unregister:<span class="cov0" title="0">
                        h.mutex.Lock()
                        delete(h.scanClients, conn)
                        delete(h.discoveryClients, conn)
                        h.mutex.Unlock()

                        h.logger.Debug("Client unregistered", "total_clients", h.getTotalClients())</span>

                case message := &lt;-h.scanBroadcast:<span class="cov0" title="0">
                        h.broadcastToClients(h.scanClients, message, "scan")</span>

                case message := &lt;-h.discoveryBroadcast:<span class="cov0" title="0">
                        h.broadcastToClients(h.discoveryClients, message, "discovery")</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        h.pingClients()</span>
                }
        }
}

// readPump pumps messages from the WebSocket connection to the hub.
func (h *WebSocketHandler) readPump(conn *websocket.Conn, requestID string) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                h.unregister &lt;- conn
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Error closing connection in readPump", "request_id", requestID, "error", err)
                }</span>
        }()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                _, _, err := conn.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{
                        if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) </span><span class="cov0" title="0">{
                                h.logger.Error("WebSocket unexpected close", "request_id", requestID, "error", err)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
                // For now, we don't process incoming messages from clients
                // In the future, this could handle subscription requests, filters, etc.
        }
}

// writePump pumps messages from the hub to the WebSocket connection.
func (h *WebSocketHandler) writePump(conn *websocket.Conn, _, requestID string) <span class="cov0" title="0">{
        ticker := time.NewTicker(pingPeriod)
        defer func() </span><span class="cov0" title="0">{
                ticker.Stop()
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Error closing connection in writePump", "request_id", requestID, "error", err)
                }</span>
        }()

        <span class="cov0" title="0">for range ticker.C </span><span class="cov0" title="0">{
                if err := conn.SetWriteDeadline(time.Now().Add(writeWait)); err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to set write deadline", "request_id", requestID, "error", err)
                        return
                }</span>
                <span class="cov0" title="0">if err := conn.WriteMessage(websocket.PingMessage, nil); err != nil </span><span class="cov0" title="0">{
                        h.logger.Debug("Ping failed, closing connection", "request_id", requestID, "error", err)
                        return
                }</span>
        }
}

// broadcastToClients sends a message to all clients of a specific type.
func (h *WebSocketHandler) broadcastToClients(clients map[*websocket.Conn]bool, message []byte, clientType string) <span class="cov0" title="0">{
        h.mutex.RLock()
        defer h.mutex.RUnlock()

        for conn := range clients </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-time.After(writeWait):<span class="cov0" title="0">
                        h.logger.Warn("Write timeout, closing connection", "client_type", clientType)
                        if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                                h.logger.Error("Error closing timed out connection", "error", err)
                        }</span>
                        <span class="cov0" title="0">delete(clients, conn)</span>
                default:<span class="cov0" title="0">
                        if err := conn.SetWriteDeadline(time.Now().Add(writeWait)); err != nil </span><span class="cov0" title="0">{
                                h.logger.Error("Failed to set write deadline", "error", err)
                                continue</span>
                        }
                        <span class="cov0" title="0">if err := conn.WriteMessage(websocket.TextMessage, message); err != nil </span><span class="cov0" title="0">{
                                h.logger.Debug("Write failed, closing connection", "client_type", clientType, "error", err)
                                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                                        h.logger.Error("Error closing failed connection", "error", err)
                                }</span>
                                <span class="cov0" title="0">delete(clients, conn)</span>
                        }
                }
        }

        // Record metrics
        <span class="cov0" title="0">if h.metrics != nil </span><span class="cov0" title="0">{
                h.metrics.Counter("websocket_messages_sent_total", map[string]string{
                        "type": clientType,
                })
        }</span>
}

// pingClients sends ping messages to all connected clients.
func (h *WebSocketHandler) pingClients() <span class="cov0" title="0">{
        h.mutex.RLock()
        defer h.mutex.RUnlock()

        allClients := make([]*websocket.Conn, 0, len(h.scanClients)+len(h.discoveryClients))
        for conn := range h.scanClients </span><span class="cov0" title="0">{
                allClients = append(allClients, conn)
        }</span>
        <span class="cov0" title="0">for conn := range h.discoveryClients </span><span class="cov0" title="0">{
                allClients = append(allClients, conn)
        }</span>

        <span class="cov0" title="0">for _, conn := range allClients </span><span class="cov0" title="0">{
                if err := conn.SetWriteDeadline(time.Now().Add(writeWait)); err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to set write deadline for ping", "error", err)
                        continue</span>
                }
                <span class="cov0" title="0">if err := conn.WriteMessage(websocket.PingMessage, nil); err != nil </span><span class="cov0" title="0">{
                        h.logger.Debug("Ping failed", "error", err)
                        h.unregister &lt;- conn
                }</span>
        }
}

// getTotalClients returns the total number of connected clients.
func (h *WebSocketHandler) getTotalClients() int <span class="cov0" title="0">{
        h.mutex.RLock()
        defer h.mutex.RUnlock()
        return len(h.scanClients) + len(h.discoveryClients)
}</span>

// BroadcastScanUpdate sends a scan update to all connected scan clients.
func (h *WebSocketHandler) BroadcastScanUpdate(update *ScanUpdateMessage) error <span class="cov0" title="0">{
        message := WebSocketMessage{
                Type:      "scan_update",
                Timestamp: time.Now().UTC(),
                Data:      update,
        }

        data, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal scan update: %w", err)
        }</span>

        <span class="cov0" title="0">select </span>{
        case h.scanBroadcast &lt;- data:<span class="cov0" title="0">
                return nil</span>
        default:<span class="cov0" title="0">
                h.logger.Warn("Scan broadcast channel full, dropping message")
                return fmt.Errorf("broadcast channel full")</span>
        }
}

// BroadcastDiscoveryUpdate sends a discovery update to all connected discovery clients.
func (h *WebSocketHandler) BroadcastDiscoveryUpdate(update *DiscoveryUpdateMessage) error <span class="cov0" title="0">{
        message := WebSocketMessage{
                Type:      "discovery_update",
                Timestamp: time.Now().UTC(),
                Data:      update,
        }

        data, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal discovery update: %w", err)
        }</span>

        <span class="cov0" title="0">select </span>{
        case h.discoveryBroadcast &lt;- data:<span class="cov0" title="0">
                return nil</span>
        default:<span class="cov0" title="0">
                h.logger.Warn("Discovery broadcast channel full, dropping message")
                return fmt.Errorf("broadcast channel full")</span>
        }
}

// BroadcastSystemMessage sends a system message to all connected clients.
func (h *WebSocketHandler) BroadcastSystemMessage(messageType, content string) error <span class="cov0" title="0">{
        message := WebSocketMessage{
                Type:      messageType,
                Timestamp: time.Now().UTC(),
                Data: map[string]string{
                        "message": content,
                },
        }

        data, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal system message: %w", err)
        }</span>

        // Send to both scan and discovery clients
        <span class="cov0" title="0">select </span>{
        case h.scanBroadcast &lt;- data:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                h.logger.Warn("Scan broadcast channel full, dropping system message")</span>
        }

        <span class="cov0" title="0">select </span>{
        case h.discoveryBroadcast &lt;- data:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                h.logger.Warn("Discovery broadcast channel full, dropping system message")</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetConnectedClients returns the number of connected clients by type.
func (h *WebSocketHandler) GetConnectedClients() map[string]int <span class="cov0" title="0">{
        h.mutex.RLock()
        defer h.mutex.RUnlock()

        return map[string]int{
                "scan":      len(h.scanClients),
                "discovery": len(h.discoveryClients),
                "total":     len(h.scanClients) + len(h.discoveryClients),
        }
}</span>

// Close gracefully shuts down the WebSocket handler.
func (h *WebSocketHandler) Close() error <span class="cov0" title="0">{
        h.mutex.Lock()
        defer h.mutex.Unlock()

        // Close all scan client connections
        for conn := range h.scanClients </span><span class="cov0" title="0">{
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Error closing scan client connection", "error", err)
                }</span>
        }

        // Close all discovery client connections
        <span class="cov0" title="0">for conn := range h.discoveryClients </span><span class="cov0" title="0">{
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Error closing discovery client connection", "error", err)
                }</span>
        }

        // Clear client maps
        <span class="cov0" title="0">h.scanClients = make(map[*websocket.Conn]bool)
        h.discoveryClients = make(map[*websocket.Conn]bool)

        h.logger.Info("WebSocket handler closed")
        return nil</span>
}

// Utility function shared with other handlers
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package middleware provides HTTP middleware functions for the Scanorama API server.
// This package implements logging, metrics, authentication, rate limiting, and other
// cross-cutting concerns for API requests.
package middleware

import (
        "context"
        "crypto/rand"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "log/slog"
        "net/http"
        "runtime/debug"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/anstrom/scanorama/internal/metrics"
)

// ContextKey represents a context key type.
type ContextKey string

const (
        // RequestIDKey is the context key for request IDs.
        RequestIDKey ContextKey = "request_id"
        // StartTimeKey is the context key for request start time.
        StartTimeKey ContextKey = "start_time"
        // httpErrorThreshold is the status code threshold for HTTP errors.
        httpErrorThreshold = 400
)

// RateLimiter implements a simple in-memory rate limiter.
type RateLimiter struct {
        requests map[string][]time.Time
        mutex    sync.RWMutex
        limit    int
        window   time.Duration
}

// NewRateLimiter creates a new rate limiter.
func NewRateLimiter(limit int, window time.Duration) *RateLimiter <span class="cov8" title="1">{
        return &amp;RateLimiter{
                requests: make(map[string][]time.Time),
                limit:    limit,
                window:   window,
        }
}</span>

// Allow checks if a request from the given IP is allowed.
func (rl *RateLimiter) Allow(ip string) bool <span class="cov8" title="1">{
        rl.mutex.Lock()
        defer rl.mutex.Unlock()

        now := time.Now()
        cutoff := now.Add(-rl.window)

        // Get existing requests for this IP
        requests, exists := rl.requests[ip]
        if !exists </span><span class="cov8" title="1">{
                requests = make([]time.Time, 0)
        }</span>

        // Filter out old requests
        <span class="cov8" title="1">filtered := make([]time.Time, 0, len(requests))
        for _, reqTime := range requests </span><span class="cov8" title="1">{
                if reqTime.After(cutoff) </span><span class="cov8" title="1">{
                        filtered = append(filtered, reqTime)
                }</span>
        }

        // Check if we're under the limit
        <span class="cov8" title="1">if len(filtered) &gt;= rl.limit </span><span class="cov8" title="1">{
                rl.requests[ip] = filtered
                return false
        }</span>

        // Add current request
        <span class="cov8" title="1">filtered = append(filtered, now)
        rl.requests[ip] = filtered

        return true</span>
}

// Cleanup removes old entries from the rate limiter.
func (rl *RateLimiter) Cleanup() <span class="cov8" title="1">{
        rl.mutex.Lock()
        defer rl.mutex.Unlock()

        now := time.Now()
        cutoff := now.Add(-rl.window * 2) // Keep some buffer

        for ip, requests := range rl.requests </span><span class="cov8" title="1">{
                filtered := make([]time.Time, 0, len(requests))
                for _, reqTime := range requests </span><span class="cov8" title="1">{
                        if reqTime.After(cutoff) </span><span class="cov0" title="0">{
                                filtered = append(filtered, reqTime)
                        }</span>
                }

                <span class="cov8" title="1">if len(filtered) == 0 </span><span class="cov8" title="1">{
                        delete(rl.requests, ip)
                }</span> else<span class="cov0" title="0"> {
                        rl.requests[ip] = filtered
                }</span>
        }
}

// Logging creates a logging middleware that logs HTTP requests and responses.
func Logging(logger *slog.Logger) func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        start := time.Now()

                        // Generate request ID
                        requestID := generateRequestID()
                        ctx := context.WithValue(r.Context(), RequestIDKey, requestID)
                        ctx = context.WithValue(ctx, StartTimeKey, start)
                        r = r.WithContext(ctx)

                        // Create response writer wrapper to capture status code
                        wrapped := &amp;responseWriter{
                                ResponseWriter: w,
                                statusCode:     http.StatusOK,
                                size:           0,
                        }

                        // Set request ID header
                        w.Header().Set("X-Request-ID", requestID)

                        // Log request
                        logger.Info("HTTP request started",
                                "request_id", requestID,
                                "method", r.Method,
                                "path", r.URL.Path,
                                "query", r.URL.RawQuery,
                                "remote_addr", getClientIP(r),
                                "user_agent", r.UserAgent(),
                                "content_length", r.ContentLength)

                        // Process request
                        next.ServeHTTP(wrapped, r)

                        // Log response
                        duration := time.Since(start)
                        logger.Info("HTTP request completed",
                                "request_id", requestID,
                                "method", r.Method,
                                "path", r.URL.Path,
                                "status", wrapped.statusCode,
                                "duration_ms", duration.Milliseconds(),
                                "response_size", wrapped.size,
                                "remote_addr", getClientIP(r))
                }</span>)
        }
}

// Metrics creates a metrics middleware that collects HTTP request metrics.
func Metrics(metricsRegistry metrics.MetricsRegistry) func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        start := time.Now()

                        // Create response writer wrapper to capture status code
                        wrapped := &amp;responseWriter{
                                ResponseWriter: w,
                                statusCode:     http.StatusOK,
                                size:           0,
                        }

                        // Process request
                        next.ServeHTTP(wrapped, r)

                        // Record metrics
                        duration := time.Since(start)
                        labels := map[string]string{
                                "method": r.Method,
                                "path":   r.URL.Path,
                                "status": strconv.Itoa(wrapped.statusCode),
                        }

                        metricsRegistry.Counter("http_requests_total", labels)
                        metricsRegistry.Histogram("http_request_duration_seconds", duration.Seconds(), labels)
                        metricsRegistry.Histogram("http_response_size_bytes", float64(wrapped.size), labels)

                        // Record error rate
                        if wrapped.statusCode &gt;= httpErrorThreshold </span><span class="cov8" title="1">{
                                errorLabels := map[string]string{
                                        "method": r.Method,
                                        "path":   r.URL.Path,
                                        "status": strconv.Itoa(wrapped.statusCode),
                                }
                                metricsRegistry.Counter("http_errors_total", errorLabels)
                        }</span>
                })
        }
}

// Recovery creates a recovery middleware that catches panics.
func Recovery(logger *slog.Logger) func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        defer func() </span><span class="cov8" title="1">{
                                if err := recover(); err != nil </span><span class="cov8" title="1">{
                                        requestID := GetRequestID(r)
                                        stack := debug.Stack()

                                        logger.Error("HTTP request panic recovered",
                                                "request_id", requestID,
                                                "method", r.Method,
                                                "path", r.URL.Path,
                                                "panic", err,
                                                "stack", string(stack),
                                                "remote_addr", getClientIP(r))

                                        // Return 500 error
                                        w.Header().Set("Content-Type", "application/json")
                                        w.WriteHeader(http.StatusInternalServerError)

                                        response := map[string]interface{}{
                                                "error":      "Internal server error",
                                                "request_id": requestID,
                                                "timestamp":  time.Now().UTC(),
                                        }

                                        if encodeErr := json.NewEncoder(w).Encode(response); encodeErr != nil </span><span class="cov0" title="0">{
                                                logger.Error("Failed to encode panic response", "error", encodeErr)
                                        }</span>
                                }
                        }()

                        <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
                })
        }
}

// Authentication creates an authentication middleware using API keys.
func Authentication(apiKeys []string, logger *slog.Logger) func(http.Handler) http.Handler <span class="cov8" title="1">{
        keySet := make(map[string]bool)
        for _, key := range apiKeys </span><span class="cov8" title="1">{
                keySet[key] = true
        }</span>

        <span class="cov8" title="1">return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        // Skip authentication for health checks
                        if r.URL.Path == "/api/v1/health" || r.URL.Path == "/api/v1/version" </span><span class="cov8" title="1">{
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        // Get API key from header
                        <span class="cov8" title="1">apiKey := r.Header.Get("X-API-Key")
                        if apiKey == "" </span><span class="cov8" title="1">{
                                // Try Authorization header as backup
                                auth := r.Header.Get("Authorization")
                                if strings.HasPrefix(auth, "Bearer ") </span><span class="cov8" title="1">{
                                        apiKey = strings.TrimPrefix(auth, "Bearer ")
                                }</span>
                        }

                        <span class="cov8" title="1">if apiKey == "" </span><span class="cov8" title="1">{
                                logger.Warn("API request without authentication",
                                        "request_id", GetRequestID(r),
                                        "path", r.URL.Path,
                                        "remote_addr", getClientIP(r))

                                w.Header().Set("Content-Type", "application/json")
                                w.WriteHeader(http.StatusUnauthorized)
                                response := map[string]interface{}{
                                        "error":      "Authentication required",
                                        "message":    "Provide API key in X-API-Key header or Authorization: Bearer &lt;key&gt;",
                                        "request_id": GetRequestID(r),
                                        "timestamp":  time.Now().UTC(),
                                }
                                _ = json.NewEncoder(w).Encode(response)
                                return
                        }</span>

                        // Validate API key
                        <span class="cov8" title="1">if !keySet[apiKey] </span><span class="cov8" title="1">{
                                logger.Warn("API request with invalid key",
                                        "request_id", GetRequestID(r),
                                        "path", r.URL.Path,
                                        "remote_addr", getClientIP(r))

                                w.Header().Set("Content-Type", "application/json")
                                w.WriteHeader(http.StatusUnauthorized)
                                response := map[string]interface{}{
                                        "error":      "Invalid API key",
                                        "request_id": GetRequestID(r),
                                        "timestamp":  time.Now().UTC(),
                                }
                                _ = json.NewEncoder(w).Encode(response)
                                return
                        }</span>

                        // Authentication successful
                        <span class="cov8" title="1">logger.Debug("API request authenticated",
                                "request_id", GetRequestID(r),
                                "path", r.URL.Path,
                                "remote_addr", getClientIP(r))

                        next.ServeHTTP(w, r)</span>
                })
        }
}

// RateLimit creates a rate limiting middleware.
func RateLimit(requests int, window time.Duration, logger *slog.Logger) func(http.Handler) http.Handler <span class="cov8" title="1">{
        limiter := NewRateLimiter(requests, window)

        // Start cleanup goroutine
        go func() </span><span class="cov8" title="1">{
                ticker := time.NewTicker(window)
                defer ticker.Stop()
                for range ticker.C </span><span class="cov0" title="0">{
                        limiter.Cleanup()
                }</span>
        }()

        <span class="cov8" title="1">return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        clientIP := getClientIP(r)

                        if !limiter.Allow(clientIP) </span><span class="cov8" title="1">{
                                logger.Warn("Rate limit exceeded",
                                        "request_id", GetRequestID(r),
                                        "client_ip", clientIP,
                                        "path", r.URL.Path,
                                        "limit", requests,
                                        "window", window)

                                w.Header().Set("Content-Type", "application/json")
                                w.Header().Set("X-RateLimit-Limit", strconv.Itoa(requests))
                                w.Header().Set("X-RateLimit-Window", window.String())
                                w.WriteHeader(http.StatusTooManyRequests)

                                response := map[string]interface{}{
                                        "error":       "Rate limit exceeded",
                                        "message":     fmt.Sprintf("Maximum %d requests per %s", requests, window),
                                        "request_id":  GetRequestID(r),
                                        "timestamp":   time.Now().UTC(),
                                        "retry_after": window.Seconds(),
                                }
                                _ = json.NewEncoder(w).Encode(response)
                                return
                        }</span>

                        // Add rate limit headers
                        <span class="cov8" title="1">w.Header().Set("X-RateLimit-Limit", strconv.Itoa(requests))
                        w.Header().Set("X-RateLimit-Window", window.String())

                        next.ServeHTTP(w, r)</span>
                })
        }
}

// ContentType creates a content type middleware that validates request content types.
func ContentType() func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        // Skip content type validation for GET, DELETE, and OPTIONS requests
                        if r.Method == "GET" || r.Method == "DELETE" || r.Method == "OPTIONS" </span><span class="cov8" title="1">{
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        // For POST and PUT requests, expect JSON content type
                        <span class="cov8" title="1">if r.Method == "POST" || r.Method == "PUT" </span><span class="cov8" title="1">{
                                contentType := r.Header.Get("Content-Type")
                                if contentType != "" &amp;&amp; !strings.HasPrefix(contentType, "application/json") </span><span class="cov8" title="1">{
                                        w.Header().Set("Content-Type", "application/json")
                                        w.WriteHeader(http.StatusUnsupportedMediaType)

                                        response := map[string]interface{}{
                                                "error":      "Unsupported media type",
                                                "message":    "Content-Type must be application/json",
                                                "expected":   "application/json",
                                                "received":   contentType,
                                                "request_id": GetRequestID(r),
                                                "timestamp":  time.Now().UTC(),
                                        }
                                        _ = json.NewEncoder(w).Encode(response)
                                        return
                                }</span>
                        }

                        <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
                })
        }
}

// responseWriter wraps http.ResponseWriter to capture response information.
type responseWriter struct {
        http.ResponseWriter
        statusCode int
        size       int
}

// WriteHeader captures the status code.
func (rw *responseWriter) WriteHeader(code int) <span class="cov8" title="1">{
        rw.statusCode = code
        rw.ResponseWriter.WriteHeader(code)
}</span>

// Write captures the response size.
func (rw *responseWriter) Write(b []byte) (int, error) <span class="cov8" title="1">{
        size, err := rw.ResponseWriter.Write(b)
        rw.size += size
        return size, err
}</span>

// generateRequestID generates a unique request ID.
func generateRequestID() string <span class="cov8" title="1">{
        bytes := make([]byte, 8)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                // Fallback to timestamp-based ID if random generation fails
                return fmt.Sprintf("req_%d", time.Now().UnixNano())
        }</span>
        <span class="cov8" title="1">return "req_" + hex.EncodeToString(bytes)</span>
}

// GetRequestID extracts the request ID from context.
func GetRequestID(r *http.Request) string <span class="cov8" title="1">{
        if requestID, ok := r.Context().Value(RequestIDKey).(string); ok </span><span class="cov8" title="1">{
                return requestID
        }</span>
        <span class="cov8" title="1">return "unknown"</span>
}

// getClientIP extracts the real client IP address from the request.
func getClientIP(r *http.Request) string <span class="cov8" title="1">{
        // Check X-Forwarded-For header first (for load balancers/proxies)
        if xff := r.Header.Get("X-Forwarded-For"); xff != "" </span><span class="cov8" title="1">{
                // Take the first IP if multiple are present
                if ips := strings.Split(xff, ","); len(ips) &gt; 0 </span><span class="cov8" title="1">{
                        return strings.TrimSpace(ips[0])
                }</span>
        }

        // Check X-Real-IP header
        <span class="cov8" title="1">if xri := r.Header.Get("X-Real-IP"); xri != "" </span><span class="cov8" title="1">{
                return xri
        }</span>

        // Fall back to RemoteAddr
        <span class="cov8" title="1">if ip := strings.Split(r.RemoteAddr, ":")[0]; ip != "" </span><span class="cov8" title="1">{
                return ip
        }</span>

        <span class="cov0" title="0">return "unknown"</span>
}

// CORS creates a simple CORS middleware.
func CORS(origins, headers, methods []string) func(http.Handler) http.Handler <span class="cov8" title="1">{
        originsMap := make(map[string]bool)
        for _, origin := range origins </span><span class="cov8" title="1">{
                originsMap[origin] = true
        }</span>

        <span class="cov8" title="1">allowAllOrigins := originsMap["*"]

        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        origin := r.Header.Get("Origin")

                        // Set CORS headers
                        if allowAllOrigins || originsMap[origin] </span><span class="cov8" title="1">{
                                w.Header().Set("Access-Control-Allow-Origin", origin)
                        }</span>

                        <span class="cov8" title="1">if len(headers) &gt; 0 </span><span class="cov8" title="1">{
                                w.Header().Set("Access-Control-Allow-Headers", strings.Join(headers, ", "))
                        }</span>

                        <span class="cov8" title="1">if len(methods) &gt; 0 </span><span class="cov8" title="1">{
                                w.Header().Set("Access-Control-Allow-Methods", strings.Join(methods, ", "))
                        }</span>

                        <span class="cov8" title="1">w.Header().Set("Access-Control-Allow-Credentials", "true")
                        w.Header().Set("Access-Control-Max-Age", "3600")

                        // Handle preflight requests
                        if r.Method == "OPTIONS" </span><span class="cov8" title="1">{
                                w.WriteHeader(http.StatusNoContent)
                                return
                        }</span>

                        <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
                })
        }
}

// RequestTimeout creates a request timeout middleware.
func RequestTimeout(timeout time.Duration) func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        ctx, cancel := context.WithTimeout(r.Context(), timeout)
                        defer cancel()

                        r = r.WithContext(ctx)
                        next.ServeHTTP(w, r)
                }</span>)
        }
}

// SecurityHeaders adds common security headers.
func SecurityHeaders() func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        // Security headers
                        w.Header().Set("X-Content-Type-Options", "nosniff")
                        w.Header().Set("X-Frame-Options", "DENY")
                        w.Header().Set("X-XSS-Protection", "1; mode=block")
                        w.Header().Set("Referrer-Policy", "strict-origin-when-cross-origin")
                        w.Header().Set("Content-Security-Policy", "default-src 'self'")

                        next.ServeHTTP(w, r)
                }</span>)
        }
}

// Compression creates a compression middleware (placeholder for now).
func Compression() func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        // TODO: Implement gzip compression
                        // For now, just pass through
                        next.ServeHTTP(w, r)
                }</span>)
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Package api provides HTTP REST API functionality for the Scanorama network scanner.
// It implements endpoints for scanning, discovery, host management, and system status.
package api

import (
        "context"
        "encoding/json"
        "fmt"
        "log/slog"
        "net"
        "net/http"
        "strconv"
        "time"

        "github.com/gorilla/handlers"
        "github.com/gorilla/mux"

        "github.com/anstrom/scanorama/internal/config"
        "github.com/anstrom/scanorama/internal/db"
        "github.com/anstrom/scanorama/internal/logging"
        "github.com/anstrom/scanorama/internal/metrics"
)

// Server timeout constants.
const (
        serverShutdownTimeout = 30 * time.Second
        healthCheckTimeout    = 5 * time.Second
)

// Server represents the API server.
type Server struct {
        httpServer *http.Server
        router     *mux.Router
        config     *config.Config
        database   *db.DB
        logger     *slog.Logger
        metrics    *metrics.Registry
}

// Config holds API server configuration.
type Config struct {
        Host              string        `yaml:"host" json:"host"`
        Port              int           `yaml:"port" json:"port"`
        ReadTimeout       time.Duration `yaml:"read_timeout" json:"read_timeout"`
        WriteTimeout      time.Duration `yaml:"write_timeout" json:"write_timeout"`
        IdleTimeout       time.Duration `yaml:"idle_timeout" json:"idle_timeout"`
        MaxHeaderBytes    int           `yaml:"max_header_bytes" json:"max_header_bytes"`
        EnableCORS        bool          `yaml:"enable_cors" json:"enable_cors"`
        CORSOrigins       []string      `yaml:"cors_origins" json:"cors_origins"`
        RateLimitEnabled  bool          `yaml:"rate_limit_enabled" json:"rate_limit_enabled"`
        RateLimitRequests int           `yaml:"rate_limit_requests" json:"rate_limit_requests"`
        RateLimitWindow   time.Duration `yaml:"rate_limit_window" json:"rate_limit_window"`
        AuthEnabled       bool          `yaml:"auth_enabled" json:"auth_enabled"`
        APIKeys           []string      `yaml:"api_keys" json:"api_keys"`
}

// DefaultConfig returns default API server configuration.
func DefaultConfig() Config <span class="cov0" title="0">{
        return Config{
                Host:              "127.0.0.1",
                Port:              8080,
                ReadTimeout:       10 * time.Second,
                WriteTimeout:      10 * time.Second,
                IdleTimeout:       60 * time.Second,
                MaxHeaderBytes:    1 &lt;&lt; 20, // 1 MB
                EnableCORS:        true,
                CORSOrigins:       []string{"*"},
                RateLimitEnabled:  true,
                RateLimitRequests: 100,
                RateLimitWindow:   time.Minute,
                AuthEnabled:       false,
                APIKeys:           []string{},
        }
}</span>

// New creates a new API server instance.
func New(cfg *config.Config, database *db.DB) (*Server, error) <span class="cov0" title="0">{
        logger := logging.Default().With("component", "api")

        // Create metrics registry
        metricsManager := metrics.NewRegistry()

        // Create router
        router := mux.NewRouter()

        // Get API config from main config
        apiConfig := getAPIConfigFromConfig(cfg)

        server := &amp;Server{
                router:   router,
                config:   cfg,
                database: database,
                logger:   logger,
                metrics:  metricsManager,
        }

        // Setup routes
        server.setupRoutes()

        // Setup middleware
        server.setupMiddleware(&amp;apiConfig)

        // Create HTTP server
        server.httpServer = &amp;http.Server{
                Addr:           net.JoinHostPort(apiConfig.Host, strconv.Itoa(apiConfig.Port)),
                Handler:        server.router,
                ReadTimeout:    apiConfig.ReadTimeout,
                WriteTimeout:   apiConfig.WriteTimeout,
                IdleTimeout:    apiConfig.IdleTimeout,
                MaxHeaderBytes: apiConfig.MaxHeaderBytes,
        }

        return server, nil
}</span>

// Start starts the API server.
func (s *Server) Start(ctx context.Context) error <span class="cov0" title="0">{
        s.logger.Info("Starting API server",
                "address", s.httpServer.Addr,
                "read_timeout", s.httpServer.ReadTimeout,
                "write_timeout", s.httpServer.WriteTimeout)

        // Start server in goroutine
        errChan := make(chan error, 1)
        go func() </span><span class="cov0" title="0">{
                if err := s.httpServer.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        errChan &lt;- fmt.Errorf("API server failed: %w", err)
                }</span>
        }()

        // Wait for context cancellation or server error
        <span class="cov0" title="0">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return s.Stop()</span>
        case err := &lt;-errChan:<span class="cov0" title="0">
                return err</span>
        }
}

// Stop gracefully stops the API server.
func (s *Server) Stop() error <span class="cov0" title="0">{
        s.logger.Info("Stopping API server")

        ctx, cancel := context.WithTimeout(context.Background(), serverShutdownTimeout)
        defer cancel()

        if err := s.httpServer.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("API server shutdown error", "error", err)
                return fmt.Errorf("server shutdown failed: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("API server stopped successfully")
        return nil</span>
}

// setupRoutes configures all API routes.
func (s *Server) setupRoutes() <span class="cov0" title="0">{
        // API version prefix
        api := s.router.PathPrefix("/api/v1").Subrouter()

        // Health and status endpoints
        api.HandleFunc("/health", s.healthHandler).Methods("GET")
        api.HandleFunc("/status", s.statusHandler).Methods("GET")
        api.HandleFunc("/version", s.versionHandler).Methods("GET")
        api.HandleFunc("/metrics", s.metricsHandler).Methods("GET")

        // Placeholder endpoints for future implementation
        // These will return "not implemented" responses for now
        api.HandleFunc("/scans", s.notImplementedHandler).Methods("GET", "POST")
        api.HandleFunc("/hosts", s.notImplementedHandler).Methods("GET", "POST")
        api.HandleFunc("/discovery", s.notImplementedHandler).Methods("GET", "POST")
        api.HandleFunc("/profiles", s.notImplementedHandler).Methods("GET", "POST")
        api.HandleFunc("/schedules", s.notImplementedHandler).Methods("GET", "POST")

        // Admin endpoints
        api.HandleFunc("/admin/status", s.adminStatusHandler).Methods("GET")

        // Static documentation (if needed)
        s.router.PathPrefix("/docs/").Handler(http.StripPrefix("/docs/", http.FileServer(http.Dir("./docs/api/"))))

        // Root redirect
        s.router.HandleFunc("/", s.redirectToAPI).Methods("GET")
}</span>

// setupMiddleware configures middleware for the API server.
func (s *Server) setupMiddleware(apiConfig *Config) <span class="cov0" title="0">{
        // Basic recovery middleware to prevent panics
        s.router.Use(s.recoveryMiddleware)

        // Basic logging middleware
        s.router.Use(s.loggingMiddleware)

        // CORS middleware
        if apiConfig.EnableCORS </span><span class="cov0" title="0">{
                corsOptions := handlers.AllowedOrigins(apiConfig.CORSOrigins)
                corsHeaders := handlers.AllowedHeaders([]string{"Content-Type", "Authorization", "X-API-Key"})
                corsMethods := handlers.AllowedMethods([]string{"GET", "POST", "PUT", "DELETE", "OPTIONS"})
                s.router.Use(handlers.CORS(corsOptions, corsHeaders, corsMethods))
        }</span>

        // Content type validation
        <span class="cov0" title="0">s.router.Use(s.contentTypeMiddleware)</span>
}

// redirectToAPI returns API information for root requests.
func (s *Server) redirectToAPI(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        response := map[string]interface{}{
                "service": "Scanorama API",
                "version": "v1",
                "endpoints": map[string]string{
                        "health": "/api/v1/health",
                        "status": "/api/v1/status",
                        "docs":   "/docs/",
                },
                "timestamp": time.Now().UTC(),
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to encode API index response", "error", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>
}

// GetRouter returns the configured router.
func (s *Server) GetRouter() *mux.Router <span class="cov0" title="0">{
        return s.router
}</span>

// GetAddress returns the server address.
func (s *Server) GetAddress() string <span class="cov0" title="0">{
        return s.httpServer.Addr
}</span>

// IsRunning checks if the server is running.
func (s *Server) IsRunning() bool <span class="cov0" title="0">{
        if s.httpServer == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Try to connect to the server
        <span class="cov0" title="0">conn, err := net.DialTimeout("tcp", s.httpServer.Addr, time.Second)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">_ = conn.Close()
        return true</span>
}

// getAPIConfigFromConfig extracts API configuration from main config.
func getAPIConfigFromConfig(cfg *config.Config) Config <span class="cov0" title="0">{
        apiConfig := DefaultConfig()

        // Override with values from main config
        apiConfig.Host = cfg.API.Host
        apiConfig.Port = cfg.API.Port
        apiConfig.ReadTimeout = cfg.API.ReadTimeout
        apiConfig.WriteTimeout = cfg.API.WriteTimeout
        apiConfig.IdleTimeout = cfg.API.IdleTimeout
        apiConfig.MaxHeaderBytes = cfg.API.MaxHeaderBytes

        // Security settings
        apiConfig.EnableCORS = cfg.API.EnableCORS
        apiConfig.CORSOrigins = cfg.API.CORSOrigins
        apiConfig.AuthEnabled = cfg.API.AuthEnabled
        apiConfig.APIKeys = cfg.API.APIKeys

        // Rate limiting
        apiConfig.RateLimitEnabled = cfg.API.RateLimitEnabled
        apiConfig.RateLimitRequests = cfg.API.RateLimitRequests
        apiConfig.RateLimitWindow = cfg.API.RateLimitWindow

        return apiConfig
}</span>

// ErrorResponse represents a standard API error response.
type ErrorResponse struct {
        Error     string    `json:"error"`
        Timestamp time.Time `json:"timestamp"`
        RequestID string    `json:"request_id,omitempty"`
}

// writeError writes a standardized error response.
func (s *Server) writeError(w http.ResponseWriter, r *http.Request, statusCode int, err error) <span class="cov0" title="0">{
        s.logger.Error("API error",
                "method", r.Method,
                "path", r.URL.Path,
                "status", statusCode,
                "error", err,
                "remote_addr", r.RemoteAddr)

        response := ErrorResponse{
                Error:     err.Error(),
                Timestamp: time.Now().UTC(),
                RequestID: getRequestID(r),
        }

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)

        if encodeErr := json.NewEncoder(w).Encode(response); encodeErr != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to encode error response", "error", encodeErr)
        }</span>
}

// Basic handler implementations

// healthHandler provides basic health check endpoint.
func (s *Server) healthHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(r.Context(), healthCheckTimeout)
        defer cancel()

        status := "healthy"
        checks := make(map[string]string)

        // Check database
        if s.database != nil </span><span class="cov0" title="0">{
                if err := s.database.Ping(ctx); err != nil </span><span class="cov0" title="0">{
                        status = "unhealthy"
                        checks["database"] = "failed: " + err.Error()
                }</span> else<span class="cov0" title="0"> {
                        checks["database"] = "ok"
                }</span>
        } else<span class="cov0" title="0"> {
                checks["database"] = "not configured"
        }</span>

        <span class="cov0" title="0">response := map[string]interface{}{
                "status":    status,
                "timestamp": time.Now().UTC(),
                "checks":    checks,
        }

        statusCode := http.StatusOK
        if status == "unhealthy" </span><span class="cov0" title="0">{
                statusCode = http.StatusServiceUnavailable
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)
        _ = json.NewEncoder(w).Encode(response)</span>
}

// statusHandler provides detailed status information.
func (s *Server) statusHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        response := map[string]interface{}{
                "service":   "scanorama-api",
                "timestamp": time.Now().UTC(),
                "uptime":    time.Since(time.Now()).String(), // Placeholder
                "version":   "0.2.0",
        }

        w.Header().Set("Content-Type", "application/json")
        _ = json.NewEncoder(w).Encode(response)
}</span>

// versionHandler provides version information.
func (s *Server) versionHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        response := map[string]interface{}{
                "version":   "0.2.0",
                "timestamp": time.Now().UTC(),
                "service":   "scanorama",
        }

        s.WriteJSON(w, r, http.StatusOK, response)
}</span>

// metricsHandler provides Prometheus-style metrics.
func (s *Server) metricsHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        metricsData := s.metrics.GetMetrics()

        response := map[string]interface{}{
                "metrics":   metricsData,
                "timestamp": time.Now().UTC(),
        }

        s.WriteJSON(w, r, http.StatusOK, response)
}</span>

// notImplementedHandler returns a not implemented response.
func (s *Server) notImplementedHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        response := map[string]interface{}{
                "error":     "endpoint not implemented",
                "timestamp": time.Now().UTC(),
                "endpoint":  r.URL.Path,
                "method":    r.Method,
        }

        s.WriteJSON(w, r, http.StatusNotImplemented, response)
}</span>

// adminStatusHandler provides administrative status information.
func (s *Server) adminStatusHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        response := map[string]interface{}{
                "admin_status": "active",
                "timestamp":    time.Now().UTC(),
                "server_info": map[string]interface{}{
                        "address":       s.httpServer.Addr,
                        "read_timeout":  s.httpServer.ReadTimeout,
                        "write_timeout": s.httpServer.WriteTimeout,
                },
        }

        s.WriteJSON(w, r, http.StatusOK, response)
}</span>

// WriteJSON writes a JSON response.
func (s *Server) WriteJSON(w http.ResponseWriter, r *http.Request, statusCode int, data interface{}) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)

        if err := json.NewEncoder(w).Encode(data); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to encode JSON response",
                        "error", err,
                        "path", r.URL.Path,
                        "method", r.Method)
                // Don't try to write another error response here as headers are already sent
        }</span>
}

// getRequestID extracts or generates a request ID.
func getRequestID(r *http.Request) string <span class="cov0" title="0">{
        // Try to get request ID from header first
        if reqID := r.Header.Get("X-Request-ID"); reqID != "" </span><span class="cov0" title="0">{
                return reqID
        }</span>

        // Generate a simple request ID
        <span class="cov0" title="0">return fmt.Sprintf("%d", time.Now().UnixNano())</span>
}

// Middleware functions

// recoveryMiddleware recovers from panics and returns a 500 error.
func (s *Server) recoveryMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if err := recover(); err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("Panic in API handler",
                                        "error", err,
                                        "path", r.URL.Path,
                                        "method", r.Method)

                                if !headersSent(w) </span><span class="cov0" title="0">{
                                        s.writeError(w, r, http.StatusInternalServerError, fmt.Errorf("internal server error"))
                                }</span>
                        }
                }()
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

// loggingMiddleware logs HTTP requests.
func (s *Server) loggingMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                start := time.Now()

                // Wrap response writer to capture status code
                wrapped := &amp;responseWriter{ResponseWriter: w, statusCode: 200}

                next.ServeHTTP(wrapped, r)

                duration := time.Since(start)

                s.logger.Info("HTTP request",
                        "method", r.Method,
                        "path", r.URL.Path,
                        "status", wrapped.statusCode,
                        "duration", duration,
                        "remote_addr", r.RemoteAddr,
                        "user_agent", r.UserAgent())

                // Record metrics
                s.metrics.Counter("http_requests_total", map[string]string{
                        "method": r.Method,
                        "status": fmt.Sprintf("%d", wrapped.statusCode),
                })

                s.metrics.Histogram("http_request_duration_seconds", duration.Seconds(), map[string]string{
                        "method": r.Method,
                })
        }</span>)
}

// contentTypeMiddleware validates content type for POST/PUT requests.
func (s *Server) contentTypeMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.Method == "POST" || r.Method == "PUT" </span><span class="cov0" title="0">{
                        contentType := r.Header.Get("Content-Type")
                        if contentType != "" &amp;&amp; contentType != "application/json" </span><span class="cov0" title="0">{
                                s.writeError(w, r, http.StatusUnsupportedMediaType,
                                        fmt.Errorf("unsupported content type: %s", contentType))
                                return
                        }</span>
                }
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

// responseWriter wraps http.ResponseWriter to capture status code.
type responseWriter struct {
        http.ResponseWriter
        statusCode int
}

func (rw *responseWriter) WriteHeader(code int) <span class="cov0" title="0">{
        rw.statusCode = code
        rw.ResponseWriter.WriteHeader(code)
}</span>

// headersSent checks if headers have been sent.
func headersSent(w http.ResponseWriter) bool <span class="cov0" title="0">{
        // This is a simplified check - in real implementations you might use
        // reflection or other techniques to determine if headers were sent
        return false
}</span>

// ParseJSON parses JSON request body into the provided struct.
func (s *Server) ParseJSON(r *http.Request, v interface{}) error <span class="cov0" title="0">{
        if r.Body == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("empty request body")
        }</span>

        <span class="cov0" title="0">decoder := json.NewDecoder(r.Body)
        decoder.DisallowUnknownFields() // Strict parsing

        if err := decoder.Decode(v); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid JSON: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetQueryParam gets a query parameter with optional default value.
func (s *Server) GetQueryParam(r *http.Request, key, defaultValue string) string <span class="cov0" title="0">{
        if value := r.URL.Query().Get(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

// GetQueryParamInt gets an integer query parameter with optional default value.
func (s *Server) GetQueryParamInt(r *http.Request, key string, defaultValue int) (int, error) <span class="cov0" title="0">{
        if value := r.URL.Query().Get(key); value != "" </span><span class="cov0" title="0">{
                return strconv.Atoi(value)
        }</span>
        <span class="cov0" title="0">return defaultValue, nil</span>
}

// GetQueryParamBool gets a boolean query parameter with optional default value.
func (s *Server) GetQueryParamBool(r *http.Request, key string, defaultValue bool) bool <span class="cov0" title="0">{
        if value := r.URL.Query().Get(key); value != "" </span><span class="cov0" title="0">{
                if parsed, err := strconv.ParseBool(value); err == nil </span><span class="cov0" title="0">{
                        return parsed
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

// ValidateRequest performs basic request validation.
func (s *Server) ValidateRequest(r *http.Request) error <span class="cov0" title="0">{
        // Check content type for POST/PUT requests
        if r.Method == "POST" || r.Method == "PUT" </span><span class="cov0" title="0">{
                contentType := r.Header.Get("Content-Type")
                if contentType != "application/json" </span><span class="cov0" title="0">{
                        return fmt.Errorf("content-type must be application/json, got: %s", contentType)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// PaginationParams represents pagination parameters.
type PaginationParams struct {
        Page     int `json:"page"`
        PageSize int `json:"page_size"`
        Offset   int `json:"offset"`
}

// GetPaginationParams extracts pagination parameters from request.
func (s *Server) GetPaginationParams(r *http.Request) PaginationParams <span class="cov0" title="0">{
        const (
                defaultPage     = 1
                defaultPageSize = 20
                maxPageSize     = 100
        )

        page, err := s.GetQueryParamInt(r, "page", defaultPage)
        if err != nil || page &lt; 1 </span><span class="cov0" title="0">{
                page = defaultPage
        }</span>

        <span class="cov0" title="0">pageSize, err := s.GetQueryParamInt(r, "page_size", defaultPageSize)
        if err != nil || pageSize &lt; 1 </span><span class="cov0" title="0">{
                pageSize = defaultPageSize
        }</span>
        <span class="cov0" title="0">if pageSize &gt; maxPageSize </span><span class="cov0" title="0">{
                pageSize = maxPageSize
        }</span>

        <span class="cov0" title="0">offset := (page - 1) * pageSize

        return PaginationParams{
                Page:     page,
                PageSize: pageSize,
                Offset:   offset,
        }</span>
}

// PaginatedResponse represents a paginated API response.
type PaginatedResponse struct {
        Data       interface{} `json:"data"`
        Pagination struct {
                Page       int   `json:"page"`
                PageSize   int   `json:"page_size"`
                TotalItems int64 `json:"total_items"`
                TotalPages int   `json:"total_pages"`
        } `json:"pagination"`
}

// WritePaginatedResponse writes a paginated response.
func (s *Server) WritePaginatedResponse(
        w http.ResponseWriter,
        r *http.Request,
        data interface{},
        params PaginationParams,
        totalItems int64,
) <span class="cov0" title="0">{
        totalPages := int((totalItems + int64(params.PageSize) - 1) / int64(params.PageSize))

        response := PaginatedResponse{
                Data: data,
        }
        response.Pagination.Page = params.Page
        response.Pagination.PageSize = params.PageSize
        response.Pagination.TotalItems = totalItems
        response.Pagination.TotalPages = totalPages

        s.WriteJSON(w, r, http.StatusOK, response)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
